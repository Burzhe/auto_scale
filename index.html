<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wardrobe Calculator — OrgSpace</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header class="header">
    <div class="logo">
      <svg viewBox="0 0 48 48" aria-hidden="true" focusable="false">
        <circle cx="24" cy="24" r="22" fill="#00a86b" opacity="0.15"></circle>
        <path d="M16 30c4 3 12 3 16-2 3-4 1-10-5-10-3 0-5 1-7 3-2-2-4-3-7-2-5 1-7 6-4 11 1 2 4 3 7 0z" fill="#00a86b"></path>
      </svg>
      <div>
        <p class="logo-title">OrgSpace</p>
        <h1>Wardrobe Calculator</h1>
      </div>
    </div>
    <nav class="header-actions">
      <button id="reset-btn" class="ghost">Новый расчёт</button>
    </nav>
  </header>

  <main>
    <section id="upload-screen" class="screen active">
      <div class="card upload-card">
        <h2>Загрузка файла</h2>
        <p class="muted">Перетащите Excel-файл или выберите его вручную.</p>
        <div class="drop-zone" id="drop-zone">
          <p>Перетащите Excel сюда</p>
          <span>или</span>
          <label class="primary" for="file-input">Выбрать файл</label>
          <input type="file" id="file-input" accept=".xls,.xlsx">
        </div>
        <div class="hint">Поддерживаются .xls и .xlsx. Расчёт происходит локально, без загрузки в интернет.</div>
        <div id="upload-error" class="upload-error hidden" role="alert"></div>
      </div>
    </section>

    <section id="mapping-screen" class="screen hidden">
      <div class="toolbar">
        <div class="template-controls">
          <select id="template-select">
            <option value="">Выбрать шаблон...</option>
          </select>
          <button id="save-template-btn" class="secondary">Сохранить шаблон</button>
          <button id="export-template-btn" class="secondary">Экспорт шаблона</button>
          <button id="import-template-btn" class="secondary">Импорт шаблона</button>
          <input type="file" id="import-template-input" accept="application/json" class="hidden">
        </div>
        <div class="sheet-controls">
          <label>Лист:</label>
          <select id="sheet-select"></select>
        </div>
      </div>

      <div class="mapping-layout">
        <div class="preview-table-wrap">
          <table id="preview-table"></table>
          <div class="preview-footer">
            <div id="cursor-indicator" class="cursor-indicator">Наведите курсор на ячейку</div>
          </div>
        </div>

        <div class="mapping-panels">
          <div class="panel">
            <h3>1. Справочник материалов</h3>
            <div class="row">
              <label>Строка начала</label>
              <input type="number" id="mat-start" min="1" value="8">
              <label>Строка конца</label>
              <input type="number" id="mat-end" min="1" value="40">
            </div>
            <div class="row">
              <label>Название</label>
              <select id="mat-name-col" data-highlight></select>
              <label>Цена ₽/м²</label>
              <select id="mat-price-col" data-highlight></select>
            </div>
            <div class="row">
              <label>Отход %</label>
              <select id="mat-waste-col" data-highlight></select>
              <label>ID материала</label>
              <select id="mat-id-col" data-highlight></select>
            </div>
            <p class="hint">Обычно ID материала в колонке F.</p>
            <button class="secondary auto-btn" data-auto="materials">Автоопределить</button>
          </div>

          <div class="panel">
            <h3>2. Габариты</h3>
            <div class="row">
              <label>Ячейка с размерами</label>
              <input type="text" id="dims-cell" placeholder="A43" data-cell-input>
            </div>
            <div class="row">
              <label>Ширина</label>
              <input type="text" id="dims-width" placeholder="B5" data-cell-input>
              <label>Глубина</label>
              <input type="text" id="dims-depth" placeholder="C5" data-cell-input>
              <label>Высота</label>
              <input type="text" id="dims-height" placeholder="D5" data-cell-input>
            </div>
            <label class="checkbox">
              <input type="checkbox" id="dims-auto">
              Определить автоматически по задним стенкам
            </label>
            <button class="secondary auto-btn" data-auto="dimensions">Автоопределить</button>
          </div>

          <div class="panel">
            <h3>3. Таблица деталей</h3>
            <div class="row">
              <label>Строка заголовков</label>
              <input type="number" id="details-header" min="1" value="50">
            </div>
            <div class="row">
              <label>Наименование</label>
              <select id="details-name-col" data-highlight></select>
              <label>Тлщн (ID)</label>
              <select id="details-thickness-col" data-highlight></select>
            </div>
            <div class="row">
              <label>Длина</label>
              <select id="details-length-col" data-highlight></select>
              <label>Ширина</label>
              <select id="details-width-col" data-highlight></select>
            </div>
            <div class="row">
              <label>Кол-во</label>
              <select id="details-qty-col" data-highlight></select>
            </div>
            <div class="row">
              <label>Строка начала</label>
              <input type="number" id="details-start" min="1" value="51">
              <label>Строка конца</label>
              <input type="number" id="details-end" min="1" value="80">
            </div>
            <button class="secondary auto-btn" data-auto="details">Автоопределить</button>
          </div>

          <div class="panel">
            <h3>4. Фурнитура (опционально)</h3>
            <div class="row">
              <label>Лист</label>
              <select id="furniture-sheet"></select>
            </div>
            <div class="row">
              <label>Строка заголовков</label>
              <input type="number" id="furniture-header" min="1" value="7">
            </div>
            <div class="row">
              <label>Код</label>
              <select id="furniture-code-col" data-highlight></select>
              <label>Количество</label>
              <select id="furniture-qty-col" data-highlight></select>
            </div>
            <div class="row">
              <label>Наименование</label>
              <select id="furniture-name-col" data-highlight></select>
              <label>Ед. изм</label>
              <select id="furniture-unit-col" data-highlight></select>
            </div>
            <div class="row">
              <label>Цена ₽</label>
              <select id="furniture-price-col" data-highlight></select>
            </div>
            <button class="secondary auto-btn" data-auto="furniture">Автоопределить</button>
          </div>

          <div class="panel">
            <h3>5. Базовая стоимость</h3>
            <div class="row">
              <label>Ячейка с прямыми затратами</label>
              <input type="text" id="base-cost-cell" placeholder="B120" data-cell-input>
            </div>
            <p class="hint">Можно выбрать ячейку с итоговой суммой «Прямые затраты».</p>
            <button class="secondary auto-btn" data-auto="cost">Автоопределить</button>
          </div>
        </div>
      </div>

      <button id="proceed-btn" class="primary">Продолжить →</button>
    </section>

    <section id="results-screen" class="screen hidden">
      <div class="toolbar">
        <button id="back-btn" class="ghost">← Назад к настройкам</button>
      </div>
      <div class="card">
        <h2>Текущие параметры</h2>
        <div class="params">
          <div>Габариты: <strong id="current-dims">—</strong></div>
          <div>Вес: <strong id="current-weight">—</strong></div>
          <div>Цена: <strong id="current-price">—</strong></div>
        </div>
      </div>

      <div class="card">
        <h2>Задайте новые размеры</h2>
        <div class="dimension-inputs">
          <div>
            <label>Ширина (мм)</label>
            <input type="number" id="new-width" placeholder="3000">
          </div>
          <div>
            <label>Глубина (мм)</label>
            <input type="number" id="new-depth" placeholder="600">
          </div>
          <div>
            <label>Высота (мм)</label>
            <input type="number" id="new-height" placeholder="2800">
          </div>
        </div>
        <div class="dimension-inputs">
          <div>
            <label>Секции (шт)</label>
            <input type="number" id="new-sections" placeholder="Авто">
          </div>
          <div>
            <label>Полки (шт)</label>
            <input type="number" id="new-shelves" placeholder="Авто">
          </div>
        </div>
        <p class="hint">Оставьте пустым, чтобы применить авторасчёт. При ширине от 800&nbsp;мм добавляется минимум одна перегородка.</p>
        <button id="calculate-btn" class="primary">✨ Рассчитать</button>
      </div>

      <div class="card hidden" id="results-card">
        <h2>Новая спецификация</h2>
        <div class="params">
          <div>Габариты: <strong id="new-dims">—</strong></div>
          <div>Вес: <strong id="new-weight">—</strong></div>
          <div>Цена: <strong id="new-price">—</strong></div>
        </div>
        <div class="params">
          <div>Секции: <strong id="structure-sections">—</strong></div>
          <div>Перегородки: <strong id="structure-partitions">—</strong></div>
          <div>Полки: <strong id="structure-shelves">—</strong></div>
        </div>

        <div id="warnings" class="warnings"></div>

        <div class="tabs">
          <button class="tab active" data-tab="corpus">Корпус</button>
          <button class="tab" data-tab="furniture">Фурнитура</button>
        </div>

        <table id="results-table"></table>

        <button id="export-btn" class="primary">Экспорт в Excel</button>
      </div>
    </section>
  </main>

  <script id="worker-src" type="text/plain">
    const MAX_SECTION_WIDTH = 1200;
    const MAX_SHELF_SPAN = 800;
    const MAX_FACADE_WIDTH = 600;
    const PARTITION_THRESHOLD = 800;

    function splitSections(totalWidth) {
      const minSections = totalWidth >= PARTITION_THRESHOLD ? 2 : 1;
      if (totalWidth <= MAX_SECTION_WIDTH && minSections === 1) {
        return [totalWidth];
      }
      const requiredSections = Math.ceil(totalWidth / MAX_SECTION_WIDTH);
      const numSections = Math.max(requiredSections, minSections);
      const baseWidth = Math.floor(totalWidth / numSections);
      const remainder = totalWidth - baseWidth * numSections;
      const sections = Array(numSections).fill(baseWidth);
      for (let i = 0; i < remainder; i += 1) {
        sections[i] += 1;
      }
      return sections;
    }

    function distributeEvenly(spanWidth, count) {
      const base = Math.floor(spanWidth / count);
      const remainder = spanWidth - base * count;
      const widths = Array(count).fill(base);
      for (let i = 0; i < remainder; i += 1) {
        widths[i] += 1;
      }
      return widths;
    }

    function calcSpansForSection(sectionWidth) {
      const spansByShelf = Math.ceil(sectionWidth / MAX_SHELF_SPAN);
      const spansByFacade = Math.ceil(sectionWidth / MAX_FACADE_WIDTH);
      let spans = Math.max(spansByShelf, spansByFacade);
      if (sectionWidth >= PARTITION_THRESHOLD) {
        spans = Math.max(spans, 2);
      }
      return spans;
    }

    function inferPartType(name) {
      const n = (name || '').toLowerCase();
      if (n.includes('бок')) return 'side';
      if (n.includes('дно') || n.includes('крыш')) return 'base';
      if (n.includes('зад') || n.includes('двп')) return 'back';
      if (n.includes('перегород')) return 'partition';
      if (n.includes('фасад') || n.includes('двер')) return 'facade';
      if (n.includes('полк')) return 'shelf';
      if (n.includes('ящик')) return 'drawer';
      if (n.includes('штанг')) return 'rod';
      return 'other';
    }

    function recalculateCorpus(spec, newWidth, newDepth, newHeight, overrides = {}) {
      const minSections = newWidth >= PARTITION_THRESHOLD ? 2 : 1;
      let sectionCountOverride = Number(overrides.sectionCount || 0);
      if (sectionCountOverride && sectionCountOverride < minSections) {
        sectionCountOverride = minSections;
      }
      const sections = sectionCountOverride
        ? distributeEvenly(newWidth, sectionCountOverride)
        : splitSections(newWidth);
      const corpus = [];
      const warnings = [];
      const sectionCount = sections.length;
      const spansPerSection = sections.map(calcSpansForSection);
      const autoSpans = spansPerSection.reduce((sum, value) => sum + value, 0);
      const overrideShelves = Number(overrides.shelfCount || 0);
      const totalSpans = overrideShelves > 0 ? overrideShelves : autoSpans;
      const shelfSpanWidth = Math.round(newWidth / totalSpans);

      let facadeTemplate = null;
      let facadeTemplateName = '';

      const buildFacadeName = (templateName, index) => {
        const raw = String(templateName || 'Фасад').trim();
        const match = raw.match(/^(.*?)(\d+)?\s*$/);
        const base = match?.[1]?.trim() || 'Фасад';
        return `${base} ${index + 1}`.trim();
      };

      spec.corpus.forEach((part) => {
        const type = inferPartType(part.name);
        const updated = { ...part };

        if (type === 'side') {
          updated.length_mm = newHeight;
          updated.width_mm = newDepth;
          updated.qty = 2;
        }

        if (type === 'base') {
          updated.length_mm = newWidth;
          updated.width_mm = newDepth;
          updated.qty = part.name.toLowerCase().includes('крыш') ? 1 : 1;
        }

        if (type === 'back') {
          updated.length_mm = newHeight;
          updated.width_mm = newWidth;
          updated.qty = sectionCount;
        }

        if (type === 'partition') {
          updated.length_mm = newHeight;
          updated.width_mm = newDepth;
          updated.qty = Math.max(sectionCount - 1, 0);
        }

        if (type === 'shelf') {
          updated.length_mm = shelfSpanWidth;
          updated.width_mm = newDepth;
          updated.qty = totalSpans;
          if (shelfSpanWidth > MAX_SHELF_SPAN) {
            warnings.push(`Пролёт полки ${shelfSpanWidth}мм превышает ${MAX_SHELF_SPAN}мм.`);
          }
        }

        if (type === 'facade') {
          if (!facadeTemplate) {
            facadeTemplate = { ...part };
            facadeTemplateName = String(part.name || 'Фасад');
          }
          return;
        }

        if (type === 'drawer') {
          updated.length_mm = Math.min(newWidth, part.length_mm);
        }

        if (type === 'other') {
          updated.length_mm = part.length_mm;
          updated.width_mm = part.width_mm;
        }

        corpus.push(updated);
      });

      if (facadeTemplate) {
        const facadePerSection = sections.map((sectionWidth) => {
          const perSection = Math.ceil(sectionWidth / MAX_FACADE_WIDTH);
          return distributeEvenly(sectionWidth, perSection);
        });
        const flatWidths = facadePerSection.flat();
        flatWidths.forEach((width, index) => {
          const facadePart = {
            ...facadeTemplate,
            name: buildFacadeName(facadeTemplateName, index),
            length_mm: newHeight,
            width_mm: width,
            qty: 1,
          };
          delete facadePart.widths_mm;
          corpus.push(facadePart);
        });
        if (Math.max(...flatWidths) > MAX_FACADE_WIDTH) {
          warnings.push('Ширина фасада превышает допустимую.');
        }
        if (spec.corpus.filter((part) => inferPartType(part.name) === 'facade').length > 1) {
          warnings.push('Обнаружено несколько фасадов: пересоздано по шаблону первого.');
        }
      }

      if (newWidth >= PARTITION_THRESHOLD && sectionCount < 2) {
        warnings.push('При ширине от 800 мм нужна минимум одна вертикальная перегородка.');
      }
      if (sectionCountOverride && sectionCountOverride < minSections) {
        warnings.push(`Количество секций увеличено до ${minSections} для соблюдения правил.`);
      }
      if (overrideShelves > 0 && totalSpans !== autoSpans) {
        warnings.push(`Количество полок установлено вручную: ${totalSpans} шт.`);
      }

      return {
        corpus,
        warnings,
        sectionCount,
        sections,
        spansPerSection,
        totalShelves: totalSpans,
        partitionCount: Math.max(sectionCount - 1, 0),
      };
    }

    function petalsPerFacade(heightMm) {
      if (heightMm <= 900) return 2;
      if (heightMm <= 1400) return 3;
      if (heightMm <= 1900) return 4;
      if (heightMm <= 2400) return 5;
      if (heightMm <= 2800) return 7;
      return 8;
    }

    function recalculateFurniture(spec, corpusResult, newHeight) {
      const furniture = [];
      const warnings = [];
      const originalSections = splitSections(spec.dims.width || 0);
      const oldSectionCount = originalSections.length || 1;
      const newSections = corpusResult.sections || [];
      const oldSpans = originalSections.reduce((sum, width) => sum + calcSpansForSection(width), 0);
      const newSpans = (corpusResult.spansPerSection || []).reduce((sum, value) => sum + value, 0);
      const spanRatio = oldSpans > 0 ? newSpans / oldSpans : 1;
      const sectionRatio = oldSectionCount > 0 ? newSections.length / oldSectionCount : 1;

      const oldShelves = spec.corpus.reduce((sum, part) => {
        return inferPartType(part.name) === 'shelf' ? sum + (part.qty || 0) : sum;
      }, 0);
      const newShelves = corpusResult.totalShelves || 0;
      if (!oldShelves || !newShelves) {
        warnings.push('⚠️ Недостаточно данных по полкам — использован пересчёт по пролётам.');
      }

      const oldFacades = spec.corpus.reduce((sum, part) => {
        return inferPartType(part.name) === 'facade' ? sum + (part.qty || 0) : sum;
      }, 0);
      const newFacades = corpusResult.corpus.reduce((sum, part) => {
        return inferPartType(part.name) === 'facade' ? sum + (part.qty || 0) : sum;
      }, 0);
      const facadeTemplate = spec.corpus.find((part) => inferPartType(part.name) === 'facade');
      const facadeHeight = facadeTemplate?.length_mm || newHeight || 2700;
      const petals = petalsPerFacade(facadeHeight);

      const oldDrawers = spec.corpus.reduce((sum, part) => {
        return inferPartType(part.name) === 'drawer' ? sum + (part.qty || 0) : sum;
      }, 0);
      const handlesDrawerQty = oldDrawers ? Math.ceil(oldDrawers * sectionRatio) : 0;

      let totalLedPower = 0;
      let totalLedLength = 0;
      const spanWidth = newSpans ? newSections.reduce((sum, width) => sum + width, 0) / newSpans : 0;
      let handleDrawerWarningAdded = false;

      if (spec.furniture && spec.furniture.length > 0) {
        spec.furniture.forEach((item) => {
          const nameLow = String(item.name || '').toLowerCase();
          const baseQty = Number(item.qty || 0);
          let newQty = baseQty;

          if (nameLow.includes('петл') || nameLow.includes('чашк') || (nameLow.includes('заглушка') && nameLow.includes('петл'))) {
            newQty = newFacades * petals;
          } else if (nameLow.includes('ручк')) {
            newQty = newFacades + handlesDrawerQty;
            if (oldDrawers && handlesDrawerQty && !handleDrawerWarningAdded) {
              warnings.push(`ℹ️ Ручки: учтены ящики ${oldDrawers}→${handlesDrawerQty} (коэф. секций ${sectionRatio.toFixed(2)})`);
              handleDrawerWarningAdded = true;
            }
          } else if (nameLow.includes('полкодерж')) {
            if (oldShelves > 0 && newShelves > 0) {
              const supportsPerShelf = baseQty / oldShelves;
              newQty = supportsPerShelf * newShelves;
            } else {
              newQty *= spanRatio;
            }
          } else if (nameLow.includes('стяжка межсекцион')) {
            const stiazkiPerConnection = Math.max(1, Math.ceil((newHeight || spec.dims.height || 0) / 700));
            newQty = newSections.length > 1 ? (newSections.length - 1) * stiazkiPerConnection : 0;
          } else if (nameLow.includes('корректор фасада')) {
            newQty = newFacades;
          } else if (nameLow.includes('винт') || nameLow.includes('ключ')) {
            newQty = baseQty ? Math.ceil(baseQty) : 2;
          } else if (nameLow.includes('штанг')) {
            if (!baseQty) {
              newQty = 0;
            } else {
              const rodsPerOriginalSection = baseQty / oldSectionCount;
              newQty = newSections.reduce((sum) => sum + Math.ceil(rodsPerOriginalSection), 0);
            }
          } else if (nameLow.includes('подсветк') || nameLow.includes('led') || nameLow.includes('освещен')) {
            newQty *= spanRatio;
            const ledLengthMm = Math.max(Math.round(spanWidth - 100), 0);
            const totalLength = (ledLengthMm / 1000) * newQty;
            const power = totalLength * 10;
            totalLedPower += power;
            totalLedLength += totalLength;
          } else {
            newQty *= spanRatio;
          }

          furniture.push({
            ...item,
            qty: Math.ceil(newQty),
            unit: item.unit || 'шт',
          });
        });
      } else {
        const hingeCount = newFacades * 4;
        const handleCount = newFacades + oldDrawers;
        const shelfHolderCount = newShelves * 4;
        const tieCount = Math.max(newSections.length - 1, 0) * 6;
        const ledCount = newSpans;
        const add = (name, qty, unit = 'шт', price = 0) => {
          furniture.push({ name, qty, unit, price });
        };
        add('Петля', hingeCount);
        add('Ручка', handleCount);
        add('Полкодержатель', shelfHolderCount);
        add('Стяжка', tieCount);
        add('LED подсветка', ledCount);
      }

      if (totalLedPower > 50) {
        warnings.push('⚠️ LED: Нужен доп. блок (мощность > 50 Вт)');
      }
      if (totalLedLength > 0) {
        const blocksNeeded = Math.ceil(totalLedLength / 5);
        warnings.push(`ℹ️ LED: Блок питания x${blocksNeeded}, ≥${Math.round(totalLedPower * 1.2 * 10) / 10} Вт`);
      }

      return { furniture, warnings };
    }

    function getMaterialDensity(materialName) {
      const mat = String(materialName || '').toLowerCase();
      if (mat.includes('лдсп') || mat.includes('дсп')) return 720;
      if (mat.includes('мдф')) return 750;
      if (mat.includes('фанер')) return 650;
      if (mat.includes('двп') || mat.includes('оргалит')) return 850;
      if (mat.includes('стекл')) return 2500;
      return 720;
    }

    function calculateWeight(parts) {
      let totalKg = 0;
      parts.forEach((part) => {
        if (!part.thickness || !part.length_mm || !part.qty) return;
        const density = getMaterialDensity(part.material);
        const widths = part.widths_mm || [part.width_mm];
        for (let i = 0; i < part.qty; i += 1) {
          const w = widths[Math.min(i, widths.length - 1)] || part.width_mm || 0;
          const volumeM3 = (part.length_mm / 1000) * (w / 1000) * (part.thickness / 1000);
          totalKg += volumeM3 * density;
        }
      });
      return Math.round(totalKg * 100) / 100;
    }

    function calculatePrice(parts, materials) {
      let total = 0;
      parts.forEach((part) => {
        if (!part.length_mm || !part.qty) return;
        const widths = part.widths_mm || [part.width_mm];
        let areaM2 = 0;
        for (let i = 0; i < part.qty; i += 1) {
          const w = widths[Math.min(i, widths.length - 1)] || part.width_mm || 0;
          areaM2 += (part.length_mm / 1000) * (w / 1000);
        }
        const material = materials[part.material_id];
        if (material) {
          const wasteFactor = 1 + (material.waste || 0) / 100;
          total += areaM2 * material.price * wasteFactor;
        }
      });
      return Math.round(total);
    }

    self.onmessage = (event) => {
      const { type, payload } = event.data;
      if (type === 'calculate') {
        const { spec, newWidth, newDepth, newHeight, overrides } = payload;
        const corpusResult = recalculateCorpus(spec, newWidth, newDepth, newHeight, overrides);
        const furnitureResult = recalculateFurniture(spec, corpusResult, newHeight);
        const updatedSpec = {
          ...spec,
          corpus: corpusResult.corpus,
          furniture: furnitureResult.furniture,
          dims: { width: newWidth, depth: newDepth, height: newHeight },
        };
        const weight = calculateWeight(updatedSpec.corpus);
        const baseMaterialCost = spec.baseMaterialCost || calculatePrice(spec.corpus, spec.materials || {});
        const newMaterialCost = calculatePrice(updatedSpec.corpus, spec.materials || {});
        let price = newMaterialCost;
        if (spec.baseCost && baseMaterialCost > 0) {
          price = spec.baseCost * (newMaterialCost / baseMaterialCost);
        }
        price = Math.round(price * 100) / 100;
        const extraWarnings = [];
        if (newHeight > 2500) {
          extraWarnings.push('⚠️ Устойчивость: добавить антиопрокидывание');
        }
        self.postMessage({
          type: 'result',
          payload: {
            spec: updatedSpec,
            warnings: [...corpusResult.warnings, ...furnitureResult.warnings, ...extraWarnings],
            weight,
            price,
            structure: {
              sections: corpusResult.sectionCount,
              shelves: corpusResult.totalShelves,
              partitions: corpusResult.partitionCount,
            },
          },
        });
      }
    };
  </script>

  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="app.js"></script>
</body>
</html>
