<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wardrobe Calculator — OrgSpace</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header class="header">
    <div class="logo">
      <svg viewBox="0 0 48 48" aria-hidden="true" focusable="false">
        <circle cx="24" cy="24" r="22" fill="#00a86b" opacity="0.15"></circle>
        <path d="M16 30c4 3 12 3 16-2 3-4 1-10-5-10-3 0-5 1-7 3-2-2-4-3-7-2-5 1-7 6-4 11 1 2 4 3 7 0z" fill="#00a86b"></path>
      </svg>
      <div>
        <p class="logo-title">OrgSpace</p>
        <h1>Wardrobe Calculator</h1>
      </div>
    </div>
    <nav class="header-actions">
      <button id="reset-btn" class="ghost">Новый расчёт</button>
    </nav>
  </header>

  <main>
    <section id="upload-screen" class="screen active">
      <div class="card upload-card">
        <h2>Загрузка файла</h2>
        <p class="muted">Перетащите Excel-файл или выберите его вручную.</p>
        <div class="drop-zone" id="drop-zone">
          <p>Перетащите Excel сюда</p>
          <span>или</span>
          <label class="primary" for="file-input">Выбрать файл</label>
          <input type="file" id="file-input" accept=".xls,.xlsx">
        </div>
        <div class="hint">Поддерживаются .xls и .xlsx. Расчёт происходит локально, без загрузки в интернет.</div>
        <div id="upload-error" class="upload-error hidden" role="alert"></div>
      </div>
    </section>

    <section id="mapping-screen" class="screen hidden">
      <div class="toolbar">
        <div class="template-controls">
          <select id="template-select">
            <option value="">Выбрать шаблон...</option>
          </select>
          <button id="save-template-btn" class="secondary">Сохранить шаблон</button>
          <button id="export-template-btn" class="secondary">Экспорт шаблона</button>
          <button id="import-template-btn" class="secondary">Импорт шаблона</button>
          <input type="file" id="import-template-input" accept="application/json" class="hidden">
        </div>
        <div class="sheet-controls">
          <label>Лист:</label>
          <select id="sheet-select"></select>
        </div>
      </div>

      <div class="mapping-layout">
        <div class="preview-table-wrap">
          <table id="preview-table"></table>
          <div class="preview-footer">
            <div id="cursor-indicator" class="cursor-indicator">Наведите курсор на ячейку</div>
          </div>
        </div>

        <div class="mapping-panels">
          <div class="panel">
            <h3>1. Справочник материалов</h3>
            <div class="row">
              <label>Строка начала</label>
              <input type="number" id="mat-start" min="1" value="8">
              <label>Строка конца</label>
              <input type="number" id="mat-end" min="1" value="40">
            </div>
            <div class="row">
              <label>Название</label>
              <select id="mat-name-col" data-highlight></select>
              <label>Цена ₽/м²</label>
              <select id="mat-price-col" data-highlight></select>
            </div>
            <div class="row">
              <label>Отход %</label>
              <select id="mat-waste-col" data-highlight></select>
              <label>ID материала</label>
              <select id="mat-id-col" data-highlight></select>
            </div>
            <p class="hint">Обычно ID материала в колонке F.</p>
            <button class="secondary auto-btn" data-auto="materials">Автоопределить</button>
          </div>

          <div class="panel">
            <h3>2. Габариты</h3>
            <div class="row">
              <label>Ячейка с размерами</label>
              <input type="text" id="dims-cell" placeholder="A43" data-cell-input>
            </div>
            <div class="row">
              <label>Ширина</label>
              <input type="text" id="dims-width" placeholder="B5" data-cell-input>
              <label>Глубина</label>
              <input type="text" id="dims-depth" placeholder="C5" data-cell-input>
              <label>Высота</label>
              <input type="text" id="dims-height" placeholder="D5" data-cell-input>
            </div>
            <label class="checkbox">
              <input type="checkbox" id="dims-auto">
              Определить автоматически по задним стенкам
            </label>
            <button class="secondary auto-btn" data-auto="dimensions">Автоопределить</button>
          </div>

          <div class="panel">
            <h3>3. Таблица деталей</h3>
            <div class="row">
              <label>Строка заголовков</label>
              <input type="number" id="details-header" min="1" value="50">
            </div>
            <div class="row">
              <label>Наименование</label>
              <select id="details-name-col" data-highlight></select>
              <label>Тлщн (ID)</label>
              <select id="details-thickness-col" data-highlight></select>
            </div>
            <div class="row">
              <label>Длина</label>
              <select id="details-length-col" data-highlight></select>
              <label>Ширина</label>
              <select id="details-width-col" data-highlight></select>
            </div>
            <div class="row">
              <label>Кол-во</label>
              <select id="details-qty-col" data-highlight></select>
            </div>
            <div class="row">
              <label>Строка начала</label>
              <input type="number" id="details-start" min="1" value="51">
              <label>Строка конца</label>
              <input type="number" id="details-end" min="1" value="80">
            </div>
            <button class="secondary auto-btn" data-auto="details">Автоопределить</button>
          </div>

          <div class="panel">
            <h3>4. Фурнитура (опционально)</h3>
            <div class="row">
              <label>Лист</label>
              <select id="furniture-sheet"></select>
            </div>
            <div class="row">
              <label>Строка заголовков</label>
              <input type="number" id="furniture-header" min="1" value="7">
            </div>
            <div class="row">
              <label>Код</label>
              <select id="furniture-code-col" data-highlight></select>
              <label>Количество</label>
              <select id="furniture-qty-col" data-highlight></select>
            </div>
            <div class="row">
              <label>Наименование</label>
              <select id="furniture-name-col" data-highlight></select>
              <label>Ед. изм</label>
              <select id="furniture-unit-col" data-highlight></select>
            </div>
            <div class="row">
              <label>Цена ₽</label>
              <select id="furniture-price-col" data-highlight></select>
            </div>
            <button class="secondary auto-btn" data-auto="furniture">Автоопределить</button>
          </div>

          <div class="panel">
            <h3>5. Базовая стоимость</h3>
            <p class="hint">Найдено автоматически:</p>
            <ul id="calc-summary-list" class="summary-list"></ul>
            <div id="calc-summary-warning" class="warnings"></div>
            <div class="row">
              <label>Ячейка с прямыми затратами</label>
              <input type="text" id="base-cost-cell" placeholder="B120" data-cell-input>
            </div>
            <p class="hint">Можно выбрать ячейку с итоговой суммой «Прямые затраты».</p>
            <button class="secondary auto-btn" data-auto="cost">Автоопределить</button>
            <details class="calc-overrides">
              <summary>Ручное переопределение итогов (если не найдено)</summary>
              <div class="row">
                <label>Вес (кг)</label>
                <input type="text" id="anchor-weight" placeholder="Лист!A1" data-cell-input>
                <label>Трудоемкость</label>
                <input type="text" id="anchor-labor-hours" placeholder="Лист!A1" data-cell-input>
              </div>
              <div class="row">
                <label>Стоимость ДСП</label>
                <input type="text" id="anchor-dsp" placeholder="Лист!A1" data-cell-input>
                <label>Стоимость Кромки</label>
                <input type="text" id="anchor-edge" placeholder="Лист!A1" data-cell-input>
              </div>
              <div class="row">
                <label>Стоимость пластика</label>
                <input type="text" id="anchor-plastic" placeholder="Лист!A1" data-cell-input>
                <label>Стоимость ткани</label>
                <input type="text" id="anchor-fabric" placeholder="Лист!A1" data-cell-input>
              </div>
              <div class="row">
                <label>Фурнитура имп.</label>
                <input type="text" id="anchor-hw-imp" placeholder="Лист!A1" data-cell-input>
                <label>Фурнитура отч.</label>
                <input type="text" id="anchor-hw-rep" placeholder="Лист!A1" data-cell-input>
              </div>
              <div class="row">
                <label>Стоимость упаковки</label>
                <input type="text" id="anchor-pack" placeholder="Лист!A1" data-cell-input>
                <label>Труд рабочих</label>
                <input type="text" id="anchor-labor" placeholder="Лист!A1" data-cell-input>
              </div>
              <div class="row">
                <label>Прямые затраты</label>
                <input type="text" id="anchor-total" placeholder="Лист!A1" data-cell-input>
              </div>
            </details>
          </div>
        </div>
      </div>

      <div id="mapping-warning" class="warnings hidden"></div>
      <button id="proceed-btn" class="primary">Продолжить →</button>
    </section>

    <section id="results-screen" class="screen hidden">
      <div class="toolbar">
        <button id="back-btn" class="ghost">← Назад к настройкам</button>
      </div>
      <div class="card">
        <h2>Базовые параметры</h2>
        <div class="params">
          <div>Габариты: <strong id="current-dims">—</strong></div>
          <div>Вес: <strong id="current-weight">—</strong></div>
          <div>Цена: <strong id="current-price">—</strong></div>
        </div>
      </div>

      <div class="card" id="validation-card">
        <h2>Проверка расчёта</h2>
        <div class="params">
          <div>BaseCost: <strong id="validation-base-cost">—</strong></div>
          <div>BaseMaterialsCost: <strong id="validation-base-materials">—</strong></div>
          <div>BaseHardwareCost: <strong id="validation-base-hardware">—</strong></div>
          <div>BaseOther: <strong id="validation-base-other">—</strong></div>
        </div>
        <div id="validation-warning" class="warnings"></div>
      </div>

      <div class="card">
        <h2>Задайте новые размеры</h2>
        <div class="dimension-inputs">
          <div>
            <label>Ширина (мм)</label>
            <input type="number" id="new-width" placeholder="3000">
          </div>
          <div>
            <label>Глубина (мм)</label>
            <input type="number" id="new-depth" placeholder="600">
          </div>
          <div>
            <label>Высота (мм)</label>
            <input type="number" id="new-height" placeholder="2800">
          </div>
        </div>
        <div class="dimension-inputs">
          <div>
            <label>Секции (шт)</label>
            <input type="number" id="new-sections" placeholder="Авто">
          </div>
          <div>
            <label>Полки (шт)</label>
            <input type="number" id="new-shelves" placeholder="Авто">
          </div>
        </div>
        <div class="dimension-inputs">
          <div>
            <label>Прочие затраты: драйвер</label>
            <select id="other-driver">
              <option value="area">Площадь материалов</option>
              <option value="parts">Кол-во деталей</option>
              <option value="sections">Кол-во секций</option>
              <option value="fixed">Фиксировано</option>
            </select>
          </div>
          <label class="checkbox">
            <input type="checkbox" id="enforce-rules">
            Применять правила конструктива (1200/800/600)
          </label>
        </div>
        <p class="hint">Оставьте пустым, чтобы применить авторасчёт. При ширине от 800&nbsp;мм добавляется минимум одна перегородка.</p>
        <button id="calculate-btn" class="primary">✨ Рассчитать</button>
      </div>

      <div class="card hidden" id="results-card">
        <h2>Новая спецификация</h2>
        <div class="params">
          <div>Габариты: <strong id="new-dims">—</strong></div>
          <div>Вес: <strong id="new-weight">—</strong></div>
          <div>Цена: <strong id="new-price">—</strong></div>
        </div>
        <div class="params">
          <div>Секции: <strong id="structure-sections">—</strong></div>
          <div>Перегородки: <strong id="structure-partitions">—</strong></div>
          <div>Полки: <strong id="structure-shelves">—</strong></div>
        </div>
        <div class="params">
          <div>Материалы: <strong id="price-materials">—</strong></div>
          <div>Фурнитура: <strong id="price-hardware">—</strong></div>
          <div>Прочие: <strong id="price-other">—</strong></div>
          <div>Итого: <strong id="price-total">—</strong></div>
        </div>

        <div id="warnings" class="warnings"></div>

        <div class="tabs">
          <button class="tab active" data-tab="corpus">Корпус</button>
          <button class="tab" data-tab="furniture">Фурнитура</button>
          <button class="tab" data-tab="calc">Разбор калькуляции</button>
        </div>

        <table id="results-table"></table>

        <div id="calc-breakdown" class="calc-breakdown hidden">
          <div class="params">
            <div>Листовых ячеек: <strong id="calc-leaf-count">—</strong></div>
            <div>Покрытие: <strong id="calc-coverage">—</strong></div>
            <div>Сумма leaf: <strong id="calc-leaf-sum">—</strong></div>
            <div>Итого по калькуляции: <strong id="calc-total">—</strong></div>
          </div>
          <table id="calc-breakdown-table"></table>
        </div>

        <button id="export-btn" class="primary">Экспорт в Excel</button>

        <details class="material-spec">
          <summary>Спецификация материала (в разработке)</summary>
          <div class="material-spec-body">
            <label for="material-spec-select">Материал</label>
            <select id="material-spec-select">
              <option value="">Выберите материал</option>
            </select>
            <p class="hint">Здесь будет пересчёт в листы и длины кромок.</p>
          </div>
        </details>
      </div>
    </section>
  </main>

  <script id="worker-src" type="text/plain">
    const MAX_SECTION_WIDTH = 1200;
    const MAX_SHELF_SPAN = 800;
    const MAX_FACADE_WIDTH = 600;
    const PARTITION_THRESHOLD = 800;

    function splitSections(totalWidth) {
      const minSections = totalWidth >= PARTITION_THRESHOLD ? 2 : 1;
      if (totalWidth <= MAX_SECTION_WIDTH && minSections === 1) {
        return [totalWidth];
      }
      const requiredSections = Math.ceil(totalWidth / MAX_SECTION_WIDTH);
      const numSections = Math.max(requiredSections, minSections);
      const baseWidth = Math.floor(totalWidth / numSections);
      const remainder = totalWidth - baseWidth * numSections;
      const sections = Array(numSections).fill(baseWidth);
      for (let i = 0; i < remainder; i += 1) {
        sections[i] += 1;
      }
      return sections;
    }

    function distributeEvenly(spanWidth, count) {
      const base = Math.floor(spanWidth / count);
      const remainder = spanWidth - base * count;
      const widths = Array(count).fill(base);
      for (let i = 0; i < remainder; i += 1) {
        widths[i] += 1;
      }
      return widths;
    }

    function calcSpansForSection(sectionWidth) {
      const spansByShelf = Math.ceil(sectionWidth / MAX_SHELF_SPAN);
      const spansByFacade = Math.ceil(sectionWidth / MAX_FACADE_WIDTH);
      let spans = Math.max(spansByShelf, spansByFacade);
      if (sectionWidth >= PARTITION_THRESHOLD) {
        spans = Math.max(spans, 2);
      }
      return spans;
    }

    function inferPartType(name) {
      const n = (name || '').toLowerCase();
      if (n.includes('бок')) return 'side';
      if (n.includes('дно') || n.includes('крыш')) return 'base';
      if (n.includes('зад') || n.includes('двп')) return 'back';
      if (n.includes('перегород')) return 'partition';
      if (n.includes('фасад') || n.includes('двер')) return 'facade';
      if (n.includes('полк')) return 'shelf';
      if (n.includes('ящик')) return 'drawer';
      if (n.includes('штанг')) return 'rod';
      return 'other';
    }

    function inferSectionCount(spec) {
      const backQty = spec.corpus.reduce((sum, part) => {
        return inferPartType(part.name) === 'back' ? sum + (part.qty || 0) : sum;
      }, 0);
      if (backQty > 0) {
        return Math.max(1, Math.round(backQty));
      }
      const partitionsQty = spec.corpus.reduce((sum, part) => {
        return inferPartType(part.name) === 'partition' ? sum + (part.qty || 0) : sum;
      }, 0);
      if (partitionsQty > 0) {
        return Math.max(1, Math.round(partitionsQty) + 1);
      }
      const fallback = splitSections(spec.dims.width || 0).length;
      return fallback || 1;
    }

    function recalculateCorpus(spec, newWidth, newDepth, newHeight, overrides = {}, enforceRules = false) {
      const sameDimensions = newWidth === spec.dims.width
        && newDepth === spec.dims.depth
        && newHeight === spec.dims.height;
      const hasOverrides = Boolean(overrides.sectionCount || overrides.shelfCount);
      if (sameDimensions && !hasOverrides) {
        const inferredSections = inferSectionCount(spec);
        const sections = distributeEvenly(spec.dims.width || 0, inferredSections);
        return {
          corpus: spec.corpus.map((part) => ({ ...part })),
          warnings: [],
          sectionCount: inferredSections,
          sections,
          spansPerSection: sections.map(calcSpansForSection),
          totalShelves: spec.corpus.reduce((sum, part) => {
            return inferPartType(part.name) === 'shelf' ? sum + (part.qty || 0) : sum;
          }, 0),
          partitionCount: Math.max(inferredSections - 1, 0),
        };
      }

      const baseSectionCount = inferSectionCount(spec);
      const ruleMinSections = newWidth >= PARTITION_THRESHOLD ? 2 : 1;
      const minSections = enforceRules
        ? Math.max(baseSectionCount || 0, ruleMinSections)
        : (baseSectionCount || ruleMinSections);
      const requiredSections = Math.ceil(newWidth / MAX_SECTION_WIDTH);
      const requestedSectionCount = Number(overrides.sectionCount || 0);
      let sectionCountOverride = requestedSectionCount;
      if (sectionCountOverride) {
        if (sectionCountOverride < minSections) {
          sectionCountOverride = minSections;
        }
        if (enforceRules && sectionCountOverride < requiredSections) {
          sectionCountOverride = requiredSections;
        }
      }
      let targetSections = sectionCountOverride || baseSectionCount || 1;
      if (enforceRules) {
        targetSections = Math.max(targetSections, minSections, requiredSections);
      }
      const sections = distributeEvenly(newWidth, targetSections);
      const corpus = [];
      const warnings = [];
      const sectionCount = sections.length;
      const spansPerSection = sections.map(calcSpansForSection);
      const autoSpans = spansPerSection.reduce((sum, value) => sum + value, 0);
      const overrideShelves = Number(overrides.shelfCount || 0);
      const oldShelves = spec.corpus.reduce((sum, part) => {
        return inferPartType(part.name) === 'shelf' ? sum + (part.qty || 0) : sum;
      }, 0);
      const baseShelvesPerSection = baseSectionCount ? oldShelves / baseSectionCount : 0;
      const autoShelves = baseShelvesPerSection
        ? Math.round(baseShelvesPerSection * sectionCount)
        : autoSpans;
      const totalShelves = overrideShelves > 0 ? overrideShelves : autoShelves;
      const shelfWidths = [];
      if (totalShelves > 0) {
        const shelvesPerSection = distributeEvenly(totalShelves, sectionCount);
        sections.forEach((sectionWidth, index) => {
          const count = shelvesPerSection[index] || 0;
          for (let i = 0; i < count; i += 1) {
            shelfWidths.push(sectionWidth);
          }
        });
      }

      let facadeTemplate = null;
      let facadeTemplateName = '';

      const buildFacadeName = (templateName, index) => {
        const raw = String(templateName || 'Фасад').trim();
        const match = raw.match(/^(.*?)(\d+)?\s*$/);
        const base = match?.[1]?.trim() || 'Фасад';
        return `${base} ${index + 1}`.trim();
      };

      spec.corpus.forEach((part) => {
        const type = inferPartType(part.name);
        const updated = { ...part };

        if (type === 'side') {
          updated.length_mm = newHeight;
          updated.width_mm = newDepth;
          updated.qty = 2;
        }

        if (type === 'base') {
          updated.length_mm = newWidth;
          updated.width_mm = newDepth;
          updated.qty = part.name.toLowerCase().includes('крыш') ? 1 : 1;
        }

        if (type === 'back') {
          updated.length_mm = newHeight;
          updated.width_mm = newWidth;
          updated.qty = sectionCount;
        }

        if (type === 'partition') {
          updated.length_mm = newHeight;
          updated.width_mm = newDepth;
          updated.qty = Math.max(sectionCount - 1, 0);
        }

        if (type === 'shelf') {
          const fallbackWidth = Math.round(newWidth / sectionCount);
          updated.length_mm = shelfWidths[0] || fallbackWidth;
          updated.width_mm = newDepth;
          updated.qty = totalShelves;
          if (shelfWidths.length) {
            updated.widths_mm = shelfWidths;
          }
          const maxShelfWidth = shelfWidths.length ? Math.max(...shelfWidths) : updated.length_mm;
          if (maxShelfWidth > MAX_SHELF_SPAN) {
            warnings.push(`Пролёт полки ${maxShelfWidth}мм превышает ${MAX_SHELF_SPAN}мм.`);
          }
        }

        if (type === 'facade') {
          if (!facadeTemplate) {
            facadeTemplate = { ...part };
            facadeTemplateName = String(part.name || 'Фасад');
          }
          return;
        }

        if (type === 'drawer') {
          updated.length_mm = Math.min(newWidth, part.length_mm);
        }

        if (type === 'other') {
          updated.length_mm = part.length_mm;
          updated.width_mm = part.width_mm;
        }

        corpus.push(updated);
      });

      if (facadeTemplate) {
        const facadePerSection = sections.map((sectionWidth) => {
          const perSection = Math.ceil(sectionWidth / MAX_FACADE_WIDTH);
          return distributeEvenly(sectionWidth, perSection);
        });
        const flatWidths = facadePerSection.flat();
        flatWidths.forEach((width, index) => {
          const facadePart = {
            ...facadeTemplate,
            name: buildFacadeName(facadeTemplateName, index),
            length_mm: newHeight,
            width_mm: width,
            qty: 1,
          };
          delete facadePart.widths_mm;
          corpus.push(facadePart);
        });
        if (Math.max(...flatWidths) > MAX_FACADE_WIDTH) {
          warnings.push('Ширина фасада превышает допустимую.');
        }
        if (spec.corpus.filter((part) => inferPartType(part.name) === 'facade').length > 1) {
          warnings.push('Обнаружено несколько фасадов: пересоздано по шаблону первого.');
        }
      }

      if (newWidth >= PARTITION_THRESHOLD && sectionCount < 2) {
        warnings.push('При ширине от 800 мм нужна минимум одна вертикальная перегородка.');
      }
      if (requestedSectionCount && requestedSectionCount < minSections) {
        warnings.push(`Количество секций увеличено до ${minSections} для соблюдения правил.`);
      }
      if (enforceRules && requestedSectionCount && requestedSectionCount < requiredSections) {
        warnings.push(`Количество секций увеличено до ${requiredSections} для ограничения ширины секции.`);
      }
      if (enforceRules && !requestedSectionCount && requiredSections > baseSectionCount) {
        warnings.push(`Количество секций увеличено до ${requiredSections} для ограничения ширины секции.`);
      }
      if (overrideShelves > 0 && totalShelves !== autoShelves) {
        warnings.push(`Количество полок установлено вручную: ${totalShelves} шт.`);
      }
      if (!enforceRules && Math.max(...sections) > MAX_SECTION_WIDTH) {
        warnings.push('Секция > 1200, требуется деление по правилам.');
      }

      return {
        corpus,
        warnings,
        sectionCount,
        sections,
        spansPerSection,
        totalShelves,
        partitionCount: Math.max(sectionCount - 1, 0),
      };
    }

    function petalsPerFacade(heightMm) {
      if (heightMm <= 900) return 2;
      if (heightMm <= 1400) return 3;
      if (heightMm <= 1900) return 4;
      if (heightMm <= 2400) return 5;
      if (heightMm <= 2800) return 7;
      return 8;
    }

    function recalculateFurniture(spec, corpusResult, newHeight) {
      const furniture = [];
      const warnings = [];
      const oldSectionCount = inferSectionCount(spec);
      const originalSections = distributeEvenly(spec.dims.width || 0, oldSectionCount);
      const newSections = corpusResult.sections || [];
      const oldSpans = originalSections.reduce((sum, width) => sum + calcSpansForSection(width), 0);
      const newSpans = (corpusResult.spansPerSection || []).reduce((sum, value) => sum + value, 0);
      const spanRatio = oldSpans > 0 ? newSpans / oldSpans : 1;
      const sectionRatio = oldSectionCount > 0 ? newSections.length / oldSectionCount : 1;

      const oldShelves = spec.corpus.reduce((sum, part) => {
        return inferPartType(part.name) === 'shelf' ? sum + (part.qty || 0) : sum;
      }, 0);
      const newShelves = corpusResult.totalShelves || 0;
      if (!oldShelves || !newShelves) {
        warnings.push('⚠️ Недостаточно данных по полкам — использован пересчёт по пролётам.');
      }

      const oldFacades = spec.corpus.reduce((sum, part) => {
        return inferPartType(part.name) === 'facade' ? sum + (part.qty || 0) : sum;
      }, 0);
      const newFacades = corpusResult.corpus.reduce((sum, part) => {
        return inferPartType(part.name) === 'facade' ? sum + (part.qty || 0) : sum;
      }, 0);
      const facadeTemplate = spec.corpus.find((part) => inferPartType(part.name) === 'facade');
      const facadeHeight = facadeTemplate?.length_mm || newHeight || 2700;
      const petals = petalsPerFacade(facadeHeight);

      const oldDrawers = spec.corpus.reduce((sum, part) => {
        return inferPartType(part.name) === 'drawer' ? sum + (part.qty || 0) : sum;
      }, 0);
      const handlesDrawerQty = oldDrawers ? Math.ceil(oldDrawers * sectionRatio) : 0;

      let totalLedPower = 0;
      let totalLedLength = 0;
      const spanWidth = newSpans ? newSections.reduce((sum, width) => sum + width, 0) / newSpans : 0;
      let handleDrawerWarningAdded = false;

      if (spec.furniture && spec.furniture.length > 0) {
        spec.furniture.forEach((item) => {
          const nameLow = String(item.name || '').toLowerCase();
          const baseQty = Number(item.qty || 0);
          let newQty = baseQty;

          if (nameLow.includes('петл') || nameLow.includes('чашк') || (nameLow.includes('заглушка') && nameLow.includes('петл'))) {
            newQty = newFacades * petals;
          } else if (nameLow.includes('ручк')) {
            newQty = newFacades + handlesDrawerQty;
            if (oldDrawers && handlesDrawerQty && !handleDrawerWarningAdded) {
              warnings.push(`ℹ️ Ручки: учтены ящики ${oldDrawers}→${handlesDrawerQty} (коэф. секций ${sectionRatio.toFixed(2)})`);
              handleDrawerWarningAdded = true;
            }
          } else if (nameLow.includes('полкодерж')) {
            if (oldShelves > 0 && newShelves > 0) {
              const supportsPerShelf = baseQty / oldShelves;
              newQty = supportsPerShelf * newShelves;
            } else {
              newQty *= spanRatio;
            }
          } else if (nameLow.includes('стяжка межсекцион')) {
            const stiazkiPerConnection = Math.max(1, Math.ceil((newHeight || spec.dims.height || 0) / 700));
            newQty = newSections.length > 1 ? (newSections.length - 1) * stiazkiPerConnection : 0;
          } else if (nameLow.includes('корректор фасада')) {
            newQty = newFacades;
          } else if (nameLow.includes('винт') || nameLow.includes('ключ')) {
            newQty = baseQty ? Math.ceil(baseQty) : 2;
          } else if (nameLow.includes('штанг')) {
            if (!baseQty) {
              newQty = 0;
            } else {
              const rodsPerOriginalSection = baseQty / oldSectionCount;
              newQty = newSections.reduce((sum) => sum + Math.ceil(rodsPerOriginalSection), 0);
            }
          } else if (nameLow.includes('подсветк') || nameLow.includes('led') || nameLow.includes('освещен')) {
            newQty *= spanRatio;
            const ledLengthMm = Math.max(Math.round(spanWidth - 100), 0);
            const totalLength = (ledLengthMm / 1000) * newQty;
            const power = totalLength * 10;
            totalLedPower += power;
            totalLedLength += totalLength;
          } else {
            newQty *= spanRatio;
          }

          furniture.push({
            ...item,
            qty: Math.ceil(newQty),
            unit: item.unit || 'шт',
          });
        });
      } else {
        const hingeCount = newFacades * 4;
        const handleCount = newFacades + oldDrawers;
        const shelfHolderCount = newShelves * 4;
        const tieCount = Math.max(newSections.length - 1, 0) * 6;
        const ledCount = newSpans;
        const add = (name, qty, unit = 'шт', price = 0) => {
          furniture.push({ name, qty, unit, price });
        };
        add('Петля', hingeCount);
        add('Ручка', handleCount);
        add('Полкодержатель', shelfHolderCount);
        add('Стяжка', tieCount);
        add('LED подсветка', ledCount);
      }

      if (totalLedPower > 50) {
        warnings.push('⚠️ LED: Нужен доп. блок (мощность > 50 Вт)');
      }
      if (totalLedLength > 0) {
        const blocksNeeded = Math.ceil(totalLedLength / 5);
        warnings.push(`ℹ️ LED: Блок питания x${blocksNeeded}, ≥${Math.round(totalLedPower * 1.2 * 10) / 10} Вт`);
      }

      return { furniture, warnings };
    }

    function getMaterialDensity(materialName) {
      const mat = String(materialName || '').toLowerCase();
      if (mat.includes('лдсп') || mat.includes('дсп')) return 720;
      if (mat.includes('мдф')) return 750;
      if (mat.includes('фанер')) return 650;
      if (mat.includes('двп') || mat.includes('оргалит')) return 850;
      if (mat.includes('стекл')) return 2500;
      return 720;
    }

    function calculateWeight(parts) {
      let totalKg = 0;
      parts.forEach((part) => {
        if (!part.thickness || !part.length_mm || !part.qty) return;
        const density = getMaterialDensity(part.material);
        const widths = part.widths_mm || [part.width_mm];
        for (let i = 0; i < part.qty; i += 1) {
          const w = widths[Math.min(i, widths.length - 1)] || part.width_mm || 0;
          const volumeM3 = (part.length_mm / 1000) * (w / 1000) * (part.thickness / 1000);
          totalKg += volumeM3 * density;
        }
      });
      return Math.round(totalKg * 100) / 100;
    }

    function calculatePrice(parts, materials) {
      let total = 0;
      parts.forEach((part) => {
        if (!part.length_mm || !part.qty) return;
        const widths = part.widths_mm || [part.width_mm];
        let areaM2 = 0;
        for (let i = 0; i < part.qty; i += 1) {
          const w = widths[Math.min(i, widths.length - 1)] || part.width_mm || 0;
          areaM2 += (part.length_mm / 1000) * (w / 1000);
        }
        const material = materials[part.material_id];
        if (material) {
          const wasteFactor = 1 + (material.waste || 0) / 100;
          total += areaM2 * material.price * wasteFactor;
        }
      });
      return Math.round(total);
    }

    function calculateFurnitureCost(furniture) {
      return furniture.reduce((sum, item) => {
        const price = Number(item.price || 0);
        if (!price || item.unit === '%') return sum;
        return sum + (Number(item.qty || 0) * price);
      }, 0);
    }

    function calculatePartArea(part) {
      if (!part.length_mm || !part.qty) return 0;
      const widths = part.widths_mm || [part.width_mm];
      let areaM2 = 0;
      for (let i = 0; i < part.qty; i += 1) {
        const w = widths[Math.min(i, widths.length - 1)] || part.width_mm || 0;
        areaM2 += (part.length_mm / 1000) * (w / 1000);
      }
      return areaM2;
    }

    function calculateDspCostFromRates(parts, rateInfo) {
      if (!rateInfo || !rateInfo.avgRate) return null;
      let total = 0;
      parts.forEach((part) => {
        const areaM2 = calculatePartArea(part);
        if (!areaM2) return;
        const thicknessKey = part.thickness ? String(part.thickness) : null;
        const rate = thicknessKey && rateInfo.byThickness?.[thicknessKey]
          ? rateInfo.byThickness[thicknessKey]
          : rateInfo.avgRate;
        total += areaM2 * rate;
      });
      return total;
    }

    function sumPartsQty(parts) {
      return parts.reduce((sum, part) => sum + (Number(part.qty || 0) || 0), 0);
    }

    function round2(value) {
      return Math.round(value * 100) / 100;
    }

    self.onmessage = (event) => {
      const { type, payload } = event.data;
      if (type === 'calculate') {
        const { spec, newWidth, newDepth, newHeight, overrides, enforceRules, otherDriver } = payload;
        const corpusResult = recalculateCorpus(spec, newWidth, newDepth, newHeight, overrides, enforceRules);
        const furnitureResult = recalculateFurniture(spec, corpusResult, newHeight);
        const updatedSpec = {
          ...spec,
          corpus: corpusResult.corpus,
          furniture: furnitureResult.furniture,
          dims: { width: newWidth, depth: newDepth, height: newHeight },
        };
        const weight = calculateWeight(updatedSpec.corpus);
        const baseMaterialsCost = spec.baseMaterialCost || calculatePrice(spec.corpus, spec.materials || {});
        const baseHardwareCostFallback = calculateFurnitureCost(spec.furniture || []);
        const calcSummary = spec.calcSummary || {};
        const baseValues = calcSummary.baseValues || {};
        const baseDspCost = Number.isFinite(baseValues.dsp) ? baseValues.dsp : baseMaterialsCost;
        const baseEdgeCost = Number.isFinite(baseValues.edge) ? baseValues.edge : 0;
        const basePlasticCost = Number.isFinite(baseValues.plastic) ? baseValues.plastic : 0;
        const baseFabricCost = Number.isFinite(baseValues.fabric) ? baseValues.fabric : 0;
        const basePackCost = Number.isFinite(baseValues.pack) ? baseValues.pack : 0;
        const baseLaborCost = Number.isFinite(baseValues.labor) ? baseValues.labor : 0;
        const baseHardwareCost = Number.isFinite(baseValues.hwImp) || Number.isFinite(baseValues.hwRep)
          ? (Number(baseValues.hwImp || 0) + Number(baseValues.hwRep || 0))
          : baseHardwareCostFallback;
        const baseTotalCost = Number.isFinite(baseValues.totalCost)
          ? baseValues.totalCost
          : (spec.baseCost ?? (baseDspCost + baseEdgeCost + basePlasticCost + baseFabricCost + baseHardwareCost));

        const newMaterialsFallback = calculatePrice(updatedSpec.corpus, spec.materials || {});
        const rateInfo = calcSummary.rates?.dsp;
        const canUseRates = Boolean(calcSummary.breakdown?.dsp?.usable && rateInfo?.avgRate);
        const newDspCost = canUseRates ? calculateDspCostFromRates(updatedSpec.corpus, rateInfo) : newMaterialsFallback;
        const baseDspForRatio = baseDspCost > 0 ? baseDspCost : baseMaterialsCost;
        const areaRatio = baseDspForRatio > 0 ? newDspCost / baseDspForRatio : 1;

        const baseParts = sumPartsQty(spec.corpus || []);
        const newParts = sumPartsQty(updatedSpec.corpus || []);
        const baseSections = inferSectionCount(spec);
        const newSections = corpusResult.sectionCount || baseSections || 1;
        const partsRatio = baseParts > 0 ? newParts / baseParts : 1;
        const sectionsRatio = baseSections > 0 ? newSections / baseSections : 1;

        const edgeRatio = areaRatio || partsRatio;
        const newEdgeCost = baseEdgeCost * edgeRatio;
        const newPlasticCost = basePlasticCost * areaRatio;
        const newFabricCost = baseFabricCost * areaRatio;
        const newHardwareCost = baseHardwareCost * sectionsRatio;
        const newPackCost = basePackCost * partsRatio;
        const newLaborCost = baseLaborCost * sectionsRatio;

        const recognizedBase = baseDspCost + baseEdgeCost + basePlasticCost + baseFabricCost
          + baseHardwareCost + basePackCost + baseLaborCost;
        const otherDelta = baseTotalCost - recognizedBase;

        const price = round2(newDspCost + newEdgeCost + newPlasticCost + newFabricCost
          + newHardwareCost + newPackCost + newLaborCost + otherDelta);
        const extraWarnings = [];
        if (newHeight > 2500) {
          extraWarnings.push('⚠️ Устойчивость: добавить антиопрокидывание');
        }
        self.postMessage({
          type: 'result',
          payload: {
            spec: updatedSpec,
            warnings: [...corpusResult.warnings, ...furnitureResult.warnings, ...extraWarnings],
            weight,
            price,
            breakdown: {
              materials: round2(newDspCost + newEdgeCost + newPlasticCost + newFabricCost),
              hardware: round2(newHardwareCost),
              other: round2(price - (newDspCost + newEdgeCost + newPlasticCost + newFabricCost + newHardwareCost)),
              total: price,
            },
            structure: {
              sections: corpusResult.sectionCount,
              shelves: corpusResult.totalShelves,
              partitions: corpusResult.partitionCount,
            },
          },
        });
      }
    };
  </script>

  <script src="vendor/xlsx.full.min.js"></script>
  <script src="app.js"></script>
</body>
</html>
