<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wardrobe Calculator — OrgSpace</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header class="header">
    <div class="logo">
      <svg viewBox="0 0 48 48" aria-hidden="true" focusable="false">
        <circle cx="24" cy="24" r="22" fill="#00a86b" opacity="0.15"></circle>
        <path d="M16 30c4 3 12 3 16-2 3-4 1-10-5-10-3 0-5 1-7 3-2-2-4-3-7-2-5 1-7 6-4 11 1 2 4 3 7 0z" fill="#00a86b"></path>
      </svg>
      <div>
        <p class="logo-title">OrgSpace</p>
        <h1>Wardrobe Calculator</h1>
      </div>
    </div>
    <nav class="header-actions">
      <button id="reset-btn" class="ghost">Новый расчёт</button>
    </nav>
  </header>

  <main>
    <section id="upload-screen" class="screen active">
      <div class="card upload-card">
        <h2>Загрузка файла</h2>
        <p class="muted">Перетащите Excel-файл или выберите его вручную.</p>
        <div class="drop-zone" id="drop-zone">
          <p>Перетащите Excel сюда</p>
          <span>или</span>
          <label class="primary" for="file-input">Выбрать файл</label>
          <input type="file" id="file-input" accept=".xls,.xlsx">
        </div>
        <div class="hint">Поддерживаются .xls и .xlsx. Расчёт происходит локально, без загрузки в интернет.</div>
        <div id="upload-error" class="upload-error hidden" role="alert"></div>
      </div>
    </section>

    <section id="mapping-screen" class="screen hidden">
      <div class="toolbar">
        <div class="template-controls">
          <select id="template-select">
            <option value="">Выбрать шаблон...</option>
          </select>
          <button id="save-template-btn" class="secondary">Сохранить шаблон</button>
          <button id="export-template-btn" class="secondary">Экспорт шаблона</button>
          <button id="import-template-btn" class="secondary">Импорт шаблона</button>
          <input type="file" id="import-template-input" accept="application/json" class="hidden">
        </div>
        <div class="sheet-controls">
          <label>Лист:</label>
          <select id="sheet-select"></select>
        </div>
      </div>

      <div class="mapping-layout">
        <div class="preview-table-wrap">
          <table id="preview-table"></table>
          <div class="preview-footer">
            <div id="cursor-indicator" class="cursor-indicator">Наведите курсор на ячейку</div>
          </div>
        </div>

        <div class="mapping-panels">
          <div class="panel">
            <h3>1. Справочник материалов</h3>
            <div class="row">
              <label>Строка начала</label>
              <input type="number" id="mat-start" min="1" value="8">
              <label>Строка конца</label>
              <input type="number" id="mat-end" min="1" value="40">
            </div>
            <div class="row">
              <label>Название</label>
              <select id="mat-name-col" data-highlight></select>
              <label>Цена ₽/м²</label>
              <select id="mat-price-col" data-highlight></select>
            </div>
            <div class="row">
              <label>Отход %</label>
              <select id="mat-waste-col" data-highlight></select>
              <label>ID материала</label>
              <select id="mat-id-col" data-highlight></select>
            </div>
            <p class="hint">Обычно ID материала в колонке F.</p>
            <button class="secondary auto-btn" data-auto="materials">Автоопределить</button>
          </div>

          <div class="panel">
            <h3>2. Габариты</h3>
            <div class="row">
              <label>Ячейка с размерами</label>
              <input type="text" id="dims-cell" placeholder="A43" data-cell-input>
            </div>
            <div class="row">
              <label>Ширина</label>
              <input type="text" id="dims-width" placeholder="B5" data-cell-input>
              <label>Глубина</label>
              <input type="text" id="dims-depth" placeholder="C5" data-cell-input>
              <label>Высота</label>
              <input type="text" id="dims-height" placeholder="D5" data-cell-input>
            </div>
            <label class="checkbox">
              <input type="checkbox" id="dims-auto">
              Определить автоматически по задним стенкам
            </label>
            <button class="secondary auto-btn" data-auto="dimensions">Автоопределить</button>
          </div>

          <div class="panel">
            <h3>3. Таблица деталей</h3>
            <div class="row">
              <label>Строка заголовков</label>
              <input type="number" id="details-header" min="1" value="50">
            </div>
            <div class="row">
              <label>Наименование</label>
              <select id="details-name-col" data-highlight></select>
              <label>Тлщн (ID)</label>
              <select id="details-thickness-col" data-highlight></select>
            </div>
            <div class="row">
              <label>Длина</label>
              <select id="details-length-col" data-highlight></select>
              <label>Ширина</label>
              <select id="details-width-col" data-highlight></select>
            </div>
            <div class="row">
              <label>Кол-во</label>
              <select id="details-qty-col" data-highlight></select>
            </div>
            <div class="row">
              <label>Строка начала</label>
              <input type="number" id="details-start" min="1" value="51">
              <label>Строка конца</label>
              <input type="number" id="details-end" min="1" value="80">
            </div>
            <button class="secondary auto-btn" data-auto="details">Автоопределить</button>
          </div>

          <div class="panel">
            <h3>4. Базовая стоимость</h3>
            <p class="hint">Найдено автоматически:</p>
            <ul id="calc-summary-list" class="summary-list"></ul>
            <div id="calc-summary-warning" class="warnings"></div>
            <div class="row">
              <label>Ячейка с прямыми затратами</label>
              <input type="text" id="base-cost-cell" placeholder="B120" data-cell-input>
            </div>
            <p class="hint">Можно выбрать ячейку с итоговой суммой «Прямые затраты».</p>
            <button class="secondary auto-btn" data-auto="cost">Автоопределить</button>
            <details class="calc-overrides">
              <summary>Ручное переопределение итогов (если не найдено)</summary>
              <div class="row">
                <label>Вес (кг)</label>
                <input type="text" id="anchor-weight" placeholder="Лист!A1" data-cell-input>
                <label>Трудоемкость</label>
                <input type="text" id="anchor-labor-hours" placeholder="Лист!A1" data-cell-input>
              </div>
              <div class="row">
                <label>Стоимость ДСП</label>
                <input type="text" id="anchor-dsp" placeholder="Лист!A1" data-cell-input>
                <label>Стоимость Кромки</label>
                <input type="text" id="anchor-edge" placeholder="Лист!A1" data-cell-input>
              </div>
              <div class="row">
                <label>Стоимость пластика</label>
                <input type="text" id="anchor-plastic" placeholder="Лист!A1" data-cell-input>
                <label>Стоимость ткани</label>
                <input type="text" id="anchor-fabric" placeholder="Лист!A1" data-cell-input>
              </div>
              <div class="row">
                <label>Фурнитура имп.</label>
                <input type="text" id="anchor-hw-imp" placeholder="Лист!A1" data-cell-input>
                <label>Фурнитура отч.</label>
                <input type="text" id="anchor-hw-rep" placeholder="Лист!A1" data-cell-input>
              </div>
              <div class="row">
                <label>Стоимость упаковки</label>
                <input type="text" id="anchor-pack" placeholder="Лист!A1" data-cell-input>
                <label>Труд рабочих</label>
                <input type="text" id="anchor-labor" placeholder="Лист!A1" data-cell-input>
              </div>
              <div class="row">
                <label>Прямые затраты</label>
                <input type="text" id="anchor-total" placeholder="Лист!A1" data-cell-input>
              </div>
            </details>
          </div>
        </div>
      </div>

      <button id="proceed-btn" class="primary">Продолжить →</button>
    </section>

    <section id="results-screen" class="screen hidden">
      <div class="toolbar">
        <button id="back-btn" class="ghost">← Назад к настройкам</button>
      </div>
      <div class="card">
        <h2>Базовые параметры</h2>
        <div class="params">
          <div>Габариты: <strong id="current-dims">—</strong></div>
          <div>Вес: <strong id="current-weight">—</strong></div>
          <div>Цена: <strong id="current-price">—</strong></div>
        </div>
      </div>

      <div class="card" id="validation-card">
        <h2>Проверка расчёта</h2>
        <div class="params">
          <div>Стоимость ДСП: <strong id="validation-dsp">—</strong></div>
          <div>Стоимость кромки: <strong id="validation-edge">—</strong></div>
          <div>Стоимость пластика: <strong id="validation-plastic">—</strong></div>
          <div>Стоимость ткани: <strong id="validation-fabric">—</strong></div>
          <div>Стоимость фурнитуры имп.: <strong id="validation-hw-imp">—</strong></div>
          <div>Стоимость фурнитуры отч.: <strong id="validation-hw-rep">—</strong></div>
          <div>Стоимость упаковки: <strong id="validation-pack">—</strong></div>
          <div>Труд рабочих: <strong id="validation-labor">—</strong></div>
          <div>Прямые затраты: <strong id="validation-total">—</strong></div>
        </div>
        <div id="validation-warning" class="warnings"></div>
      </div>

      <div class="card">
        <h2>Задайте новые размеры</h2>
        <div class="dimension-inputs">
          <div>
            <label>Ширина (мм)</label>
            <input type="number" id="new-width" placeholder="3000">
          </div>
          <div>
            <label>Глубина (мм)</label>
            <input type="number" id="new-depth" placeholder="600">
          </div>
          <div>
            <label>Высота (мм)</label>
            <input type="number" id="new-height" placeholder="2800">
          </div>
        </div>
        <div class="dimension-inputs">
          <div>
            <label>Секции (шт)</label>
            <input type="number" id="new-sections" placeholder="Авто">
          </div>
          <div>
            <label>Полки (шт)</label>
            <input type="number" id="new-shelves" placeholder="Авто">
          </div>
        </div>
        <div class="dimension-inputs">
          <div>
            <label>Прочие затраты: драйвер</label>
            <select id="other-driver">
              <option value="area">Площадь материалов</option>
              <option value="parts">Кол-во деталей</option>
              <option value="sections">Кол-во секций</option>
              <option value="fixed">Фиксировано</option>
            </select>
          </div>
          <label class="checkbox">
            <input type="checkbox" id="enforce-rules" checked>
            Применять правила конструктива (1200/800/600)
          </label>
        </div>
        <p class="hint">Оставьте пустым, чтобы применить авторасчёт. При ширине от 800&nbsp;мм добавляется минимум одна перегородка.</p>
        <button id="calculate-btn" class="primary">✨ Рассчитать</button>
      </div>

      <div class="card hidden" id="results-card">
        <h2>Новая спецификация</h2>
        <div class="params">
          <div>Габариты: <strong id="new-dims">—</strong></div>
          <div>Вес: <strong id="new-weight">—</strong></div>
          <div>Цена: <strong id="new-price">—</strong></div>
        </div>
        <div class="params">
          <div>Секции: <strong id="structure-sections">—</strong></div>
          <div>Перегородки: <strong id="structure-partitions">—</strong></div>
          <div>Полки: <strong id="structure-shelves">—</strong></div>
        </div>
        <div class="params">
          <div>Материалы: <strong id="price-materials">—</strong></div>
          <div>Фурнитура: <strong id="price-hardware">—</strong></div>
          <div>Прочие: <strong id="price-other">—</strong></div>
          <div>Итого: <strong id="price-total">—</strong></div>
        </div>

        <div id="warnings" class="warnings"></div>

        <div class="tabs">
          <button class="tab active" data-tab="corpus">Корпус</button>
          <button class="tab" data-tab="furniture">Фурнитура</button>
          <button class="tab" data-tab="calc">Разбор калькуляции</button>
        </div>

        <div id="furniture-summary" class="furniture-summary hidden"></div>

        <table id="results-table"></table>

        <div id="calc-breakdown" class="calc-breakdown hidden">
          <div class="params">
            <div>Листовых ячеек: <strong id="calc-leaf-count">—</strong></div>
            <div>Покрытие: <strong id="calc-coverage">—</strong></div>
            <div>Сумма leaf: <strong id="calc-leaf-sum">—</strong></div>
            <div>Итого по калькуляции: <strong id="calc-total">—</strong></div>
          </div>
          <div id="calc-breakdown-reason" class="hint"></div>
          <button id="calc-toggle-sources" class="secondary hidden" type="button">Показать источники</button>
          <table id="calc-breakdown-table"></table>
        </div>

        <button id="export-btn" class="primary">Экспорт в Excel</button>

        <details class="material-spec">
          <summary>Спецификация материала (в разработке)</summary>
          <div class="material-spec-body">
            <label for="material-spec-select">Материал</label>
            <select id="material-spec-select">
              <option value="">Выберите материал</option>
            </select>
            <p class="hint">Здесь будет пересчёт в листы и длины кромок.</p>
          </div>
        </details>
      </div>
    </section>
  </main>

  <script id="worker-src" type="text/plain">
    const MAX_SECTION_WIDTH = 1200;
    const MAX_SHELF_SPAN = 800;
    const MAX_FACADE_WIDTH = 600;
    const PARTITION_THRESHOLD = 800;

    function splitSections(totalWidth) {
      const minSections = totalWidth >= PARTITION_THRESHOLD ? 2 : 1;
      if (totalWidth <= MAX_SECTION_WIDTH && minSections === 1) {
        return [totalWidth];
      }
      const requiredSections = Math.ceil(totalWidth / MAX_SECTION_WIDTH);
      const numSections = Math.max(requiredSections, minSections);
      const baseWidth = Math.floor(totalWidth / numSections);
      const remainder = totalWidth - baseWidth * numSections;
      const sections = Array(numSections).fill(baseWidth);
      for (let i = 0; i < remainder; i += 1) {
        sections[i] += 1;
      }
      return sections;
    }

    function distributeEvenly(spanWidth, count) {
      const base = Math.floor(spanWidth / count);
      const remainder = spanWidth - base * count;
      const widths = Array(count).fill(base);
      for (let i = 0; i < remainder; i += 1) {
        widths[i] += 1;
      }
      return widths;
    }

    function calcSpansForSection(sectionWidth) {
      const spansByShelf = Math.ceil(sectionWidth / MAX_SHELF_SPAN);
      const spansByFacade = Math.ceil(sectionWidth / MAX_FACADE_WIDTH);
      let spans = Math.max(spansByShelf, spansByFacade);
      if (sectionWidth >= PARTITION_THRESHOLD) {
        spans = Math.max(spans, 2);
      }
      return spans;
    }

    function inferPartType(name) {
      const n = (name || '').toLowerCase();
      if (n.includes('бок')) return 'side';
      if (n.includes('дно') || n.includes('крыш')) return 'base';
      if (n.includes('зад') || n.includes('двп')) return 'back';
      if (n.includes('перегород')) return 'partition';
      if (n.includes('фасад') || n.includes('двер')) return 'facade';
      if (n.includes('полк')) return 'shelf';
      if (n.includes('ящик')) return 'drawer';
      if (n.includes('штанг')) return 'rod';
      return 'other';
    }

    function inferSectionCount(spec) {
      const backs = (spec.corpus || []).filter((p) => inferPartType(p.name) === 'back' && (p.qty || 0) > 0);
      if (backs.length) {
        const qtys = backs.map((p) => Math.round(p.qty || 0)).filter((n) => n > 0);
        const freq = new Map();
        qtys.forEach((n) => freq.set(n, (freq.get(n) || 0) + 1));
        let best = 0;
        let bestCnt = -1;
        for (const [n, c] of freq.entries()) {
          if (c > bestCnt) {
            best = n;
            bestCnt = c;
          }
        }
        if (best > 0) return best;
        return Math.max(1, Math.round(Math.max(...qtys)));
      }

      const partitionsQty = (spec.corpus || []).reduce((sum, part) => {
        return inferPartType(part.name) === 'partition' ? sum + (part.qty || 0) : sum;
      }, 0);
      if (partitionsQty > 0) {
        return Math.max(1, Math.round(partitionsQty) + 1);
      }

      return splitSections((spec.dims && spec.dims.width) || 0).length || 1;
    }


    function mode(values) {
      const freq = new Map();
      values.forEach((v) => {
        if (!Number.isFinite(v)) return;
        freq.set(v, (freq.get(v) || 0) + 1);
      });
      let best = null;
      let bestCount = -1;
      for (const [value, count] of freq.entries()) {
        if (count > bestCount) {
          best = value;
          bestCount = count;
        }
      }
      return best;
    }

    
    function approxEqual(a, b, tol = 25) {
      return Math.abs((a || 0) - (b || 0)) <= tol;
    }

    function pickTemplate(parts, fallbackNameContains = null) {
      if (!parts || !parts.length) return null;
      if (fallbackNameContains) {
        const found = parts.find((p) => String(p.name || '').toLowerCase().includes(fallbackNameContains));
        if (found) return found;
      }
      return parts[0];
    }

    function detectModuleWidth(spec, baseSections) {
      const parts = spec.corpus || [];
      const candidates = [];

      // Prefer shelves/base parts (length ~ module width)
      parts.forEach((p) => {
        const t = inferPartType(p.name);
        if ((t === 'shelf' || t === 'base') && p.length_mm && p.length_mm > 300 && p.length_mm < 1400) {
          candidates.push(Math.round(p.length_mm));
        }
      });

      // Then backs (width ~ module width)
      parts.forEach((p) => {
        const t = inferPartType(p.name);
        if (t === 'back' && p.width_mm && p.width_mm > 300 && p.width_mm < 1400) {
          candidates.push(Math.round(p.width_mm));
        }
      });

      if (candidates.length) {
        const freq = new Map();
        candidates.forEach((n) => freq.set(n, (freq.get(n) || 0) + 1));
        let best = candidates[0];
        let bestCnt = -1;
        for (const [n, c] of freq.entries()) {
          if (c > bestCnt) {
            best = n;
            bestCnt = c;
          }
        }
        return best;
      }

      const w = (spec.dims && spec.dims.width) || 0;
      const s = baseSections || 1;
      return Math.round(w / s) || 0;
    }

    function detectFacadeTiers(facadeParts) {
      const tiers = new Map(); // height -> {template, qty}
      (facadeParts || []).forEach((p) => {
        const h = Math.round(p.length_mm || 0);
        if (!h) return;
        const entry = tiers.get(h) || { template: p, qty: 0 };
        entry.qty += p.qty || 0;
        // prefer the row with larger qty as template
        if ((p.qty || 0) > (entry.template.qty || 0)) entry.template = p;
        tiers.set(h, entry);
      });

      const arr = Array.from(tiers.entries())
        .map(([h, v]) => ({ height: h, template: v.template, qty: v.qty }))
        .sort((a, b) => b.height - a.height);

      return arr;
    }

    function detectPlinthHeight(spec, tierHeights) {
      const parts = spec.corpus || [];
      const plinth = parts.find((p) => String(p.name || '').toLowerCase().includes('цокол'));
      if (plinth) {
        const candidates = [plinth.length_mm, plinth.width_mm].filter((v) => Number.isFinite(v) && v > 0);
        if (candidates.length) {
          const height = Math.min(...candidates);
          if (height > 0 && height < 500) return Math.round(height);
        }
      }

      const baseH = (spec.dims && spec.dims.height) || 0;
      const sumTiers = (tierHeights || []).reduce((s, h) => s + (h || 0), 0);
      const diff = baseH - sumTiers;
      if (diff > 0 && diff < 400) return Math.round(diff);
      return 0;
    }

    function scaleTierHeights(baseTiers, baseHeight, newHeight, basePlinth) {
      const tiers = (baseTiers || []).filter((n) => n > 0);
      if (!tiers.length) return { plinth: Math.max(0, Math.round(newHeight || 0)), tiers: [] };

      const baseTiersSum = tiers.reduce((s, n) => s + n, 0);
      const basePl = Math.max(0, Math.round(basePlinth || 0));
      const baseH = Math.max(0, Math.round(baseHeight || 0));

      const baseClearance = Math.max(0, Math.round(baseH - baseTiersSum - basePl));
      const pl = basePl;
      const available = Math.max(0, Math.round(baseClearance > 0 ? (newHeight - baseClearance) : newHeight));
      const k = available / (baseTiersSum || 1);
      const scaled = tiers.map((h) => Math.max(1, Math.round(h * k)));

      // Fix rounding drift on last tier
      const sumScaled = scaled.reduce((s, n) => s + n, 0);
      if (scaled.length) scaled[scaled.length - 1] += available - sumScaled;

      return { plinth: pl, tiers: scaled };
    }

    function groupAdd(map, key, inc) {
      map.set(key, (map.get(key) || 0) + inc);
    }

    function clonePart(template, overrides) {
      const base = {
        name: template.name || '',
        material_id: template.material_id || '',
        material: template.material || '',
        thickness: template.thickness || 16,
        length_mm: template.length_mm || 0,
        width_mm: template.width_mm || 0,
        qty: template.qty || 0,
      };
      return Object.assign(base, overrides);
    }

    function recalculateCorpus(spec, newWidth, newDepth, newHeight, overrides = {}, enforceRules = true) {
      const baseWidth = (spec.dims && spec.dims.width) || 0;
      const baseDepth = (spec.dims && spec.dims.depth) || 0;
      const baseHeight = (spec.dims && spec.dims.height) || 0;

      const baseSections = inferSectionCount(spec);
      let modules = enforceRules
        ? Math.max(1, Math.ceil(newWidth / MAX_SECTION_WIDTH))
        : Math.max(1, baseSections);
      if (overrides.sectionCount !== undefined && overrides.sectionCount !== null && overrides.sectionCount !== '') {
        modules = Math.max(1, Math.round(overrides.sectionCount));
      }

      const moduleWidths = distributeEvenly(newWidth, modules);

      const parts = spec.corpus || [];
      const shelvesBase = parts.filter((p) => inferPartType(p.name) === 'shelf');
      const facadesBase = parts.filter((p) => inferPartType(p.name) === 'facade');
      const backsBase = parts.filter((p) => inferPartType(p.name) === 'back');
      const sidesBase = parts.filter((p) => inferPartType(p.name) === 'side');
      const basesBase = parts.filter((p) => inferPartType(p.name) === 'base');
      const partitionsBase = parts.filter((p) => inferPartType(p.name) === 'partition');
      const plinthBase = parts.filter((p) => String(p.name || '').toLowerCase().includes('цокол'));

      const shelfTpl = pickTemplate(shelvesBase);
      const baseTpls = basesBase.length ? basesBase : [];
      const backTpls = backsBase.length ? backsBase : [];
      const sideTpls = sidesBase.length ? sidesBase : [];
      const partitionTpl = pickTemplate(partitionsBase, 'перегород');
      const plinthTpl = pickTemplate(plinthBase);

      const facadeTiersBase = detectFacadeTiers(facadesBase);
      let baseTierHeights = facadeTiersBase.map((t) => t.height);
      if (!baseTierHeights.length && sideTpls.length) {
        baseTierHeights = Array.from(new Set(sideTpls.map((p) => Math.round(p.length_mm || 0))).values())
          .filter((n) => n > 0)
          .sort((a, b) => b - a);
      }
      const basePlinth = detectPlinthHeight(spec, baseTierHeights);
      const plinthHeight = basePlinth || 0;
      const doorHeight = Math.max(0, Math.round(newHeight - plinthHeight));
      const baseDoorSum = baseTierHeights.reduce((s, h) => s + h, 0) || doorHeight;
      const scaledTierHeights = baseTierHeights.length
        ? baseTierHeights.map((h) => Math.max(1, Math.round((h / baseDoorSum) * doorHeight)))
        : [];
      if (scaledTierHeights.length) {
        const drift = doorHeight - scaledTierHeights.reduce((s, h) => s + h, 0);
        scaledTierHeights[scaledTierHeights.length - 1] += drift;
      }

      const baseModuleWidth = baseSections ? Math.round(baseWidth / baseSections) : baseWidth;
      const baseShelfLength = shelfTpl?.length_mm || 0;
      const baseModuleCount = baseShelfLength ? Math.max(1, Math.round(baseWidth / baseShelfLength)) : baseSections || 1;

      const shelvesTotalBase = shelvesBase.reduce((s, p) => s + (p.qty || 0), 0);
      const baseShelvesPerModule = baseModuleCount ? shelvesTotalBase / baseModuleCount : 0;
      let shelvesTotal = shelvesTotalBase;
      if (overrides.shelfCount !== undefined && overrides.shelfCount !== null && overrides.shelfCount !== '') {
        shelvesTotal = Math.max(0, Math.round(overrides.shelfCount));
      } else if (baseShelvesPerModule) {
        shelvesTotal = Math.max(0, Math.round(baseShelvesPerModule * modules));
      }
      const shelvesPerModule = distributeEvenly(shelvesTotal, modules);

      const baseDoorsTotal = facadeTiersBase.length
        ? Math.max(...facadeTiersBase.map((t) => Math.round(t.qty || 0)), 1)
        : 0;
      const baseDoorsPerModule = baseSections && baseDoorsTotal ? Math.max(1, Math.round(baseDoorsTotal / baseSections)) : 1;

      const facadePlan = new Map();
      let totalDoors = 0;
      let internalPartitions = 0;
      moduleWidths.forEach((mw) => {
        const doorsPerModule = enforceRules
          ? Math.max(1, Math.ceil(mw / MAX_FACADE_WIDTH))
          : Math.max(1, baseDoorsPerModule);
        const doorWidth = Math.max(1, Math.round(mw / doorsPerModule));
        totalDoors += doorsPerModule;
        internalPartitions += Math.max(0, doorsPerModule - 1);
        groupAdd(facadePlan, doorWidth, doorsPerModule);
      });

      const newParts = [];
      const warnings = [];

      if (shelfTpl) {
        const map = new Map();
        moduleWidths.forEach((mw, i) => groupAdd(map, mw, shelvesPerModule[i] || 0));
        for (const [mw, qty] of map.entries()) {
          if (!qty) continue;
          newParts.push(clonePart(shelfTpl, { length_mm: mw, width_mm: newDepth, qty }));
        }
      }

      baseTpls.forEach((tpl) => {
        const perModule = baseSections && tpl.qty ? tpl.qty / baseSections : tpl.qty || 0;
        const isModuleSized = approxEqual(tpl.length_mm, baseModuleWidth, 60);
        const widthScaled = approxEqual(tpl.width_mm, baseDepth, 60) ? newDepth : tpl.width_mm;

        if (isModuleSized && perModule) {
          const map = new Map();
          moduleWidths.forEach((mw) => groupAdd(map, mw, perModule));
          for (const [mw, qty] of map.entries()) {
            if (!qty) continue;
            newParts.push(clonePart(tpl, { length_mm: mw, width_mm: widthScaled, qty: Math.round(qty) }));
          }
        } else {
          const scaleW = baseWidth ? newWidth / baseWidth : 1;
          newParts.push(clonePart(tpl, {
            length_mm: Math.round((tpl.length_mm || 0) * scaleW),
            width_mm: widthScaled,
            qty: tpl.qty || 0,
          }));
        }
      });

      if (plinthTpl) {
        const perModule = baseSections && plinthTpl.qty ? plinthTpl.qty / baseSections : 1;
        const map = new Map();
        moduleWidths.forEach((mw) => groupAdd(map, mw, perModule));
        for (const [mw, qty] of map.entries()) {
          newParts.push(clonePart(plinthTpl, { length_mm: mw, width_mm: plinthHeight || plinthTpl.width_mm, qty: Math.round(qty) }));
        }
      }

      if (sideTpls.length && scaledTierHeights.length) {
        const baseHeights = Array.from(new Set(sideTpls.map((p) => Math.round(p.length_mm || 0))).values())
          .filter((n) => n > 0)
          .sort((a, b) => b - a);
        baseHeights.forEach((bh, idx) => {
          const tpl = sideTpls.find((p) => Math.round(p.length_mm || 0) === bh) || sideTpls[0];
          const perModule = baseSections && tpl.qty ? tpl.qty / baseSections : 2;
          const h = scaledTierHeights[Math.min(idx, scaledTierHeights.length - 1)];
          newParts.push(clonePart(tpl, { length_mm: h, width_mm: newDepth, qty: Math.round(perModule * modules) }));
        });
      }

      if (backTpls.length && scaledTierHeights.length) {
        const baseHeights = Array.from(new Set(backTpls.map((p) => Math.round(p.length_mm || 0))).values())
          .filter((n) => n > 0)
          .sort((a, b) => b - a);
        baseHeights.forEach((bh, idx) => {
          const tpl = backTpls.find((p) => Math.round(p.length_mm || 0) === bh) || backTpls[0];
          const h = scaledTierHeights[Math.min(idx, scaledTierHeights.length - 1)];
          const map = new Map();
          moduleWidths.forEach((mw) => groupAdd(map, mw, 1));
          for (const [mw, qty] of map.entries()) {
            newParts.push(clonePart(tpl, { length_mm: h, width_mm: mw, qty: Math.round(qty) }));
          }
        });
      }

      if (facadeTiersBase.length && scaledTierHeights.length) {
        facadeTiersBase.forEach((tier, idx) => {
          const tpl = tier.template;
          const h = scaledTierHeights[Math.min(idx, scaledTierHeights.length - 1)];
          const name = tpl.name || `фасад${idx + 1}`;
          for (const [width, qty] of facadePlan.entries()) {
            newParts.push(clonePart(tpl, { name, length_mm: h, width_mm: width, qty: Math.round(qty) }));
          }
        });
      }

      if (partitionTpl) {
        const betweenModules = Math.max(0, modules - 1);
        const totalPartitions = betweenModules + internalPartitions;
        if (totalPartitions > 0) {
          const lengthScaled = approxEqual(partitionTpl.length_mm, baseHeight, 60)
            ? newHeight
            : Math.round((partitionTpl.length_mm || 0) * (baseHeight ? newHeight / baseHeight : 1));
          const widthScaled = approxEqual(partitionTpl.width_mm, baseDepth, 60) ? newDepth : partitionTpl.width_mm;
          newParts.push(clonePart(partitionTpl, { length_mm: lengthScaled, width_mm: widthScaled, qty: totalPartitions }));
        }
      }

      const regenerated = new Set(['shelf', 'facade', 'back', 'side', 'base', 'partition']);
      parts.forEach((p) => {
        const t = inferPartType(p.name);
        if (regenerated.has(t)) return;
        if (String(p.name || '').toLowerCase().includes('цокол')) return;

        const widthScaled = approxEqual(p.width_mm, baseDepth, 60) ? newDepth : p.width_mm;
        const lengthScaled = approxEqual(p.length_mm, baseDepth, 60) ? newDepth : p.length_mm;
        newParts.push(Object.assign({}, p, { width_mm: widthScaled, length_mm: lengthScaled }));
      });

      return {
        corpus: newParts,
        warnings,
        sectionCount: modules,
        totalShelves: shelvesTotal,
        partitionCount: Math.max(0, modules - 1) + internalPartitions,
      };
    }

    function getMaterialDensity(materialName) {
      const mat = String(materialName || '').toLowerCase();
      if (mat.includes('лдсп') || mat.includes('дсп')) return 730;
      if (mat.includes('мдф')) return 750;
      if (mat.includes('фанер')) return 650;
      if (mat.includes('двп') || mat.includes('оргалит')) return 850;
      if (mat.includes('стекл')) return 2500;
      return 730;
    }

    function calculatePartArea(part) {
      if (!part.length_mm || !part.width_mm || !part.qty) return 0;
      return (part.length_mm * part.width_mm * part.qty) / 1e6;
    }

    function inferDensityFromSpec(spec) {
      const baseWeight = Number(spec?.calcSummary?.baseValues?.weight);
      if (!Number.isFinite(baseWeight) || baseWeight <= 0) return 730;
      const volume = (spec?.corpus || []).reduce((sum, part) => {
        if (!part.thickness || !part.length_mm || !part.width_mm || !part.qty) return sum;
        const areaM2 = (part.length_mm / 1000) * (part.width_mm / 1000);
        const thicknessM = part.thickness / 1000;
        return sum + areaM2 * thicknessM * part.qty;
      }, 0);
      if (!volume) return 730;
      const density = baseWeight / volume;
      return Number.isFinite(density) && density > 0 ? density : 730;
    }

    function calculateWeight(parts, density = 730) {
      let totalKg = 0;
      parts.forEach((part) => {
        if (!part.thickness || !part.length_mm || !part.width_mm || !part.qty) return;
        const areaM2 = (part.length_mm / 1000) * (part.width_mm / 1000);
        const thicknessM = part.thickness / 1000;
        totalKg += density * areaM2 * thicknessM * part.qty;
      });
      return Math.round(totalKg * 100) / 100;
    }

    function calculatePrice(parts, materials) {
      let total = 0;
      parts.forEach((part) => {
        if (!part.length_mm || !part.width_mm || !part.qty) return;
        const areaM2 = (part.length_mm / 1000) * (part.width_mm / 1000) * part.qty;
        const material = materials[part.material_id];
        if (material) {
          const wasteFactor = 1 + (material.waste || 0) / 100;
          total += areaM2 * material.price * wasteFactor;
        }
      });
      return Math.round(total);
    }

    function calculateFurnitureCost(furniture) {
      return (furniture || []).reduce((sum, item) => {
        const price = Number(item.price || 0);
        if (!price || item.unit === '%') return sum;
        return sum + Number(item.qty || 0) * price;
      }, 0);
    }

    function petalsPerFacade(heightMm) {
      if (heightMm <= 900) return 2;
      if (heightMm <= 1400) return 3;
      if (heightMm <= 1900) return 4;
      if (heightMm <= 2400) return 5;
      if (heightMm <= 2800) return 7;
      return 8;
    }

    function recalculateFurniture(spec, baseValues, corpusResult, newHeight, newWidth) {
      const baseFurniture = Array.isArray(spec?.furniture) ? spec.furniture : [];
      const baseHwImp = Number(baseValues?.hwImp || 0);
      const baseHwRep = Number(baseValues?.hwRep || 0);
      const warnings = [];
      const priceWarnings = new Set();

      const oldSectionCount = inferSectionCount(spec);
      const newSectionCount = corpusResult?.sectionCount || oldSectionCount || 1;
      const originalSections = distributeEvenly((spec.dims && spec.dims.width) || 0, Math.max(oldSectionCount, 1));
      const newSections = distributeEvenly(newWidth || (spec.dims && spec.dims.width) || 0, Math.max(newSectionCount, 1));
      const oldSpans = originalSections.reduce((sum, width) => sum + calcSpansForSection(width), 0);
      const newSpans = newSections.reduce((sum, width) => sum + calcSpansForSection(width), 0);
      const spanRatio = oldSpans > 0 ? newSpans / oldSpans : 1;
      const sectionRatio = oldSectionCount > 0 ? newSectionCount / oldSectionCount : 1;

      const oldShelves = (spec.corpus || []).reduce((sum, part) => {
        return inferPartType(part.name) === 'shelf' ? sum + (part.qty || 0) : sum;
      }, 0);
      const newShelves = Number.isFinite(corpusResult?.totalShelves) ? corpusResult.totalShelves : 0;
      if (!oldShelves || !newShelves) {
        warnings.push('⚠️ Недостаточно данных по полкам — пересчёт по пролётам.');
      }

      const oldFacades = (spec.corpus || []).reduce((sum, part) => {
        return inferPartType(part.name) === 'facade' ? sum + (part.qty || 0) : sum;
      }, 0);
      const newFacades = (corpusResult?.corpus || []).reduce((sum, part) => {
        return inferPartType(part.name) === 'facade' ? sum + (part.qty || 0) : sum;
      }, 0);
      const facadeTemplate = (spec.corpus || []).find((part) => inferPartType(part.name) === 'facade');
      const facadeHeight = facadeTemplate?.length_mm || newHeight || (spec.dims && spec.dims.height) || 0;
      const petals = petalsPerFacade(facadeHeight || 0);

      const oldDrawers = (spec.corpus || []).reduce((sum, part) => {
        return inferPartType(part.name) === 'drawer' ? sum + (part.qty || 0) : sum;
      }, 0);
      const handlesDrawerQty = oldDrawers ? Math.ceil(oldDrawers * sectionRatio) : 0;
      const handleItems = baseFurniture.filter((item) => String(item.name || '').toLowerCase().includes('ручк'));
      const baseHandlesTotal = handleItems.reduce((sum, item) => sum + Number(item.qty || 0), 0);
      const baseHandlesForFacades = Math.max(baseHandlesTotal - oldDrawers, 0);
      const handleFacadeRatio = oldFacades > 0 ? baseHandlesForFacades / oldFacades : 0;
      let handleFacadeRatioWarningAdded = false;

      let totalLedPower = 0;
      let totalLedLength = 0;
      const totalSpanWidth = newSections.reduce((sum, width) => sum + width, 0);
      const spanWidth = newSpans ? totalSpanWidth / newSpans : 0;
      let handleDrawerWarningAdded = false;

      const furniture = [];
      if (baseFurniture.length) {
        baseFurniture.forEach((item) => {
          const nameLow = String(item.name || '').toLowerCase();
          const baseQty = Number(item.qty || 0);
          let newQty = baseQty;
          if (item.priceDerivedFromSum && baseQty > 0) {
            const label = item.name || item.code || 'позиция';
            const col = item.priceDerivedFromSumColumn || 'J';
            const msg = `⚠️ Фурнитура: цена "${label}" рассчитана из суммы ${col} / кол-во.`;
            if (!priceWarnings.has(msg)) {
              warnings.push(msg);
              priceWarnings.add(msg);
            }
          }
          if (item.unit !== '%') {
            if (nameLow.includes('петл') || nameLow.includes('чашк') || (nameLow.includes('заглушка') && nameLow.includes('петл'))) {
              newQty = newFacades * petals;
            } else if (nameLow.includes('ручк')) {
              const handlesForFacades = handleFacadeRatio > 0 ? newFacades * handleFacadeRatio : 0;
              const totalHandles = handlesForFacades + handlesDrawerQty;
              if (baseHandlesTotal > 0) {
                const share = baseQty / baseHandlesTotal;
                newQty = totalHandles * share;
              } else {
                newQty = totalHandles;
              }
              if (oldDrawers && handlesDrawerQty && !handleDrawerWarningAdded) {
                warnings.push(`ℹ️ Ручки: учтены ящики ${oldDrawers}→${handlesDrawerQty} (коэф. секций ${sectionRatio.toFixed(2)})`);
                handleDrawerWarningAdded = true;
              }
              if (oldFacades && baseHandlesForFacades > 0 && !handleFacadeRatioWarningAdded && Math.abs(handleFacadeRatio - 1) > 0.01) {
                warnings.push(`ℹ️ Ручки: доля на фасады ${Math.round(handleFacadeRatio * 100)}% (фасады ${oldFacades}→${newFacades})`);
                handleFacadeRatioWarningAdded = true;
              }
            } else if (nameLow.includes('полкодерж')) {
              if (oldShelves > 0 && newShelves > 0) {
                const supportsPerShelf = baseQty / oldShelves;
                newQty = supportsPerShelf * newShelves;
              } else {
                newQty *= spanRatio;
              }
            } else if (nameLow.includes('стяжка межсекцион')) {
              const stiazkiPerConnection = Math.max(1, Math.ceil((newHeight || spec.dims?.height || 0) / 700));
              newQty = newSectionCount > 1 ? (newSectionCount - 1) * stiazkiPerConnection : 0;
            } else if (nameLow.includes('корректор фасада')) {
              newQty = newFacades;
            } else if (nameLow.includes('винт') || nameLow.includes('ключ')) {
              newQty = baseQty ? Math.ceil(baseQty) : 2;
            } else if (nameLow.includes('штанг')) {
              if (!baseQty) {
                newQty = 0;
              } else {
                const rodsPerOriginalSection = baseQty / Math.max(oldSectionCount, 1);
                newQty = newSectionCount * Math.ceil(rodsPerOriginalSection);
              }
            } else if (nameLow.includes('подсветк') || nameLow.includes('led') || nameLow.includes('освещен')) {
              newQty *= spanRatio;
              const ledLengthMm = Math.max(Math.round(spanWidth - 100), 0);
              const totalLength = (ledLengthMm / 1000) * newQty;
              const power = totalLength * 10;
              totalLedPower += power;
              totalLedLength += totalLength;
            } else {
              newQty *= spanRatio;
            }
          }

          const roundedQty = Math.ceil(newQty);
          const coef = Number(item.coef || 1);
          const price = Number(item.price || 0);
          const sum = item.unit === '%' ? Number(item.sum || 0) : round2(roundedQty * price * coef);
          furniture.push({
            ...item,
            qty: roundedQty,
            unit: item.unit || 'шт',
            sum,
          });
        });
      } else {
        const hingeCount = newFacades * petals;
        const handleCount = newFacades + handlesDrawerQty;
        const shelfHolderCount = newShelves * 4;
        const tieCount = Math.max(newSectionCount - 1, 0) * 6;
        const ledCount = newSpans;
        const add = (name, qty, unit = 'шт', price = 0) => {
          furniture.push({ name, qty, unit, price, sum: round2(qty * price) });
        };
        add('Петля', hingeCount);
        add('Ручка', handleCount);
        add('Полкодержатель', shelfHolderCount);
        add('Стяжка', tieCount);
        add('LED подсветка', ledCount);
      }

      if (totalLedPower > 50) {
        warnings.push('⚠️ LED: Нужен доп. блок (мощность > 50 Вт)');
      }
      if (totalLedLength > 0) {
        const blocksNeeded = Math.ceil(totalLedLength / 5);
        warnings.push(`ℹ️ LED: Блок питания x${blocksNeeded}, ≥${Math.round(totalLedPower * 1.2 * 10) / 10} Вт`);
      }

      let imp = 0;
      let rep = 0;
      furniture.forEach((row) => {
        const s = Number(row.sum || 0);
        if (row.origin === 0) imp += s;
        if (row.origin === 1) rep += s;
      });
      const useTotals = imp + rep > 0;
      return {
        furniture,
        hwImp: useTotals ? imp : baseHwImp,
        hwRep: useTotals ? rep : baseHwRep,
        warnings,
      };
    }

function calculateDspCostFromRates(parts, rateInfo) {
      if (!rateInfo || !rateInfo.avgRate) return null;
      let total = 0;
      parts.forEach((part) => {
        const areaM2 = calculatePartArea(part);
        if (!areaM2) return;
        const thicknessKey = part.thickness ? String(part.thickness) : null;
        const rate = thicknessKey && rateInfo.byThickness?.[thicknessKey]
          ? rateInfo.byThickness[thicknessKey]
          : rateInfo.avgRate;
        total += areaM2 * rate;
      });
      return total;
    }

    function sumPartsQty(parts) {
      return parts.reduce((sum, part) => sum + (Number(part.qty || 0) || 0), 0);
    }

    function round2(value) {
      return Math.round(value * 100) / 100;
    }

    self.onmessage = (event) => {
      const { type, payload } = event.data;
      if (type === 'calculate') {
        const { spec, newWidth, newDepth, newHeight, overrides, enforceRules, otherDriver } = payload;
        const corpusResult = recalculateCorpus(spec, newWidth, newDepth, newHeight, overrides, enforceRules);
        const calcSummary = spec.calcSummary || {};
        const baseValues = calcSummary.baseValues || {};
        const furnitureResult = recalculateFurniture(spec, baseValues, corpusResult, newHeight, newWidth);
        const updatedSpec = {
          ...spec,
          corpus: corpusResult.corpus,
          furniture: furnitureResult.furniture,
          dims: { width: newWidth, depth: newDepth, height: newHeight },
        };
        const density = inferDensityFromSpec(spec);
        const weight = calculateWeight(updatedSpec.corpus, density);
        const baseMaterialsCost = spec.baseMaterialCost || calculatePrice(spec.corpus, spec.materials || {});
        const baseHardwareCostFallback = calculateFurnitureCost(spec.furniture || []);
        const baseDspCost = Number.isFinite(baseValues.dsp) ? baseValues.dsp : baseMaterialsCost;
        const baseEdgeCost = Number.isFinite(baseValues.edge) ? baseValues.edge : 0;
        const basePlasticCost = Number.isFinite(baseValues.plastic) ? baseValues.plastic : 0;
        const baseFabricCost = Number.isFinite(baseValues.fabric) ? baseValues.fabric : 0;
        const basePackCost = Number.isFinite(baseValues.pack) ? baseValues.pack : 0;
        const baseLaborCost = Number.isFinite(baseValues.labor) ? baseValues.labor : 0;
        const baseHardwareCost = Number.isFinite(baseValues.hwImp) || Number.isFinite(baseValues.hwRep)
          ? (Number(baseValues.hwImp || 0) + Number(baseValues.hwRep || 0))
          : (Number(furnitureResult.hwImp || 0) + Number(furnitureResult.hwRep || 0)) || baseHardwareCostFallback;
        const baseTotalCost = Number.isFinite(baseValues.totalCost)
          ? baseValues.totalCost
          : (spec.baseCost ?? (baseDspCost + baseEdgeCost + basePlasticCost + baseFabricCost + baseHardwareCost));

        const newMaterialsFallback = calculatePrice(updatedSpec.corpus, spec.materials || {});
        const rateInfo = calcSummary.rates?.dsp;
        const canUseRates = Boolean(calcSummary.breakdown?.dsp?.usable && rateInfo?.avgRate);
        const newDspCost = canUseRates ? calculateDspCostFromRates(updatedSpec.corpus, rateInfo) : newMaterialsFallback;
        const baseDspForRatio = baseDspCost > 0 ? baseDspCost : baseMaterialsCost;
        const areaRatio = baseDspForRatio > 0 ? newDspCost / baseDspForRatio : 1;

        const baseParts = sumPartsQty(spec.corpus || []);
        const newParts = sumPartsQty(updatedSpec.corpus || []);
        const baseSections = inferSectionCount(spec);
        const newSections = corpusResult.sectionCount || baseSections || 1;
        const partsRatio = baseParts > 0 ? newParts / baseParts : 1;
        const sectionsRatio = baseSections > 0 ? newSections / baseSections : 1;

        const edgeRatio = areaRatio || partsRatio;
        const newEdgeCost = baseEdgeCost * edgeRatio;
        const newPlasticCost = basePlasticCost * areaRatio;
        const newFabricCost = baseFabricCost * areaRatio;
        const newHardwareCost = baseHardwareCost * sectionsRatio;
        const newPackCost = basePackCost * partsRatio;
        const newLaborCost = baseLaborCost * sectionsRatio;

        const recognizedBase = baseDspCost + baseEdgeCost + basePlasticCost + baseFabricCost
          + baseHardwareCost + basePackCost + baseLaborCost;
        const otherDelta = baseTotalCost - recognizedBase;
        let otherRatio = 1;
        if (otherDriver === 'area') otherRatio = areaRatio;
        if (otherDriver === 'parts') otherRatio = partsRatio;
        if (otherDriver === 'sections') otherRatio = sectionsRatio;
        if (otherDriver === 'fixed') otherRatio = 1;
        const newOther = otherDelta * otherRatio;

        const price = round2(newDspCost + newEdgeCost + newPlasticCost + newFabricCost
          + newHardwareCost + newPackCost + newLaborCost + newOther);
        const extraWarnings = [];
        if (newHeight > 2500) {
          extraWarnings.push('⚠️ Устойчивость: добавить антиопрокидывание');
        }
        self.postMessage({
          type: 'result',
          payload: {
            spec: updatedSpec,
            warnings: [...corpusResult.warnings, ...furnitureResult.warnings, ...extraWarnings],
            weight,
            price,
            breakdown: {
              materials: round2(newDspCost + newEdgeCost + newPlasticCost + newFabricCost),
              hardware: round2(newHardwareCost),
              other: round2(price - (newDspCost + newEdgeCost + newPlasticCost + newFabricCost + newHardwareCost)),
              total: price,
            },
            structure: {
              sections: corpusResult.sectionCount,
              shelves: corpusResult.totalShelves,
              partitions: corpusResult.partitionCount,
            },
          },
        });
      }
    };
  </script>

  <script src="vendor/xlsx.full.min.js"></script>
  <script src="app-utils.js"></script>
  <script src="app-scaling.js"></script>
  <script src="app-parser.js"></script>
  <script src="app.js"></script>
</body>
</html>
